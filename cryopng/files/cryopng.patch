diff -Naur optipng-0.7.5/src/libpng/pngstruct.h cryopng/src/libpng/pngstruct.h
--- optipng-0.7.5/src/libpng/pngstruct.h	2014-03-07 04:35:01.000000000 +1000
+++ cryopng/src/libpng/pngstruct.h	2014-04-29 08:49:36.000000000 +1000
@@ -226,6 +226,9 @@
                                * This is a pointer into big_row_buf
                                */
 #ifdef PNG_WRITE_SUPPORTED
+   png_bytep none_row;        /* buffer to save "none" row when filtering */
+   png_bytep dirty_row;       /* buffer to save "dirty" row when filtering */
+   png_bytep dirtz_row;       /* buffer to save "dirtz" row when filtering */
    png_bytep sub_row;         /* buffer to save "sub" row when filtering */
    png_bytep up_row;          /* buffer to save "up" row when filtering */
    png_bytep avg_row;         /* buffer to save "avg" row when filtering */
diff -Naur optipng-0.7.5/src/libpng/pngwrite.c cryopng/src/libpng/pngwrite.c
--- optipng-0.7.5/src/libpng/pngwrite.c	2014-03-07 04:35:01.000000000 +1000
+++ cryopng/src/libpng/pngwrite.c	2014-04-29 09:06:53.000000000 +1000
@@ -930,6 +930,9 @@
    png_free_buffer_list(png_ptr, &png_ptr->zbuffer_list);
    png_free(png_ptr, png_ptr->row_buf);
 #ifdef PNG_WRITE_FILTER_SUPPORTED
+   png_free(png_ptr, png_ptr->none_row);
+   png_free(png_ptr, png_ptr->dirty_row);
+   png_free(png_ptr, png_ptr->dirtz_row);
    png_free(png_ptr, png_ptr->prev_row);
    png_free(png_ptr, png_ptr->sub_row);
    png_free(png_ptr, png_ptr->up_row);
@@ -1042,6 +1045,25 @@
       if (png_ptr->row_buf != NULL)
       {
 #ifdef PNG_WRITE_FILTER_SUPPORTED
+         if ((png_ptr->do_filter & PNG_FILTER_NONE) && png_ptr->none_row == NULL)
+         {
+            png_ptr->none_row = (png_bytep)png_malloc(png_ptr,
+                (png_ptr->rowbytes + 1));
+            png_ptr->none_row[0] = PNG_FILTER_VALUE_NONE;
+         }
+
+         if ((png_ptr->do_filter & PNG_FILTER_AVG) && png_ptr->dirty_row == NULL)
+         {
+            png_ptr->dirty_row = (png_bytep)png_malloc(png_ptr,
+                (png_ptr->rowbytes + 1));
+         }
+		  
+         if ((png_ptr->do_filter & PNG_FILTER_PAETH) && png_ptr->dirtz_row == NULL)
+         {
+            png_ptr->dirtz_row = (png_bytep)png_malloc(png_ptr,
+                (png_ptr->rowbytes + 1));
+         }
+
          if ((png_ptr->do_filter & PNG_FILTER_SUB) && png_ptr->sub_row == NULL)
          {
             png_ptr->sub_row = (png_bytep)png_malloc(png_ptr,
diff -Naur optipng-0.7.5/src/libpng/pngwutil.c cryopng/src/libpng/pngwutil.c
--- optipng-0.7.5/src/libpng/pngwutil.c	2014-03-07 04:35:01.000000000 +1000
+++ cryopng/src/libpng/pngwutil.c	2014-04-29 09:52:50.000000000 +1000
@@ -1973,6 +1973,9 @@
 
 #ifdef PNG_WRITE_FILTER_SUPPORTED
    /* Set up filtering buffer, if using this filter */
+   png_ptr->none_row = (png_bytep)png_malloc(png_ptr, png_ptr->rowbytes + 1);
+   png_ptr->none_row[0] = PNG_FILTER_VALUE_NONE;
+
    if (png_ptr->do_filter & PNG_FILTER_SUB)
    {
       png_ptr->sub_row = (png_bytep)png_malloc(png_ptr, png_ptr->rowbytes + 1);
@@ -1985,6 +1988,8 @@
    {
       /* Set up previous row buffer */
       png_ptr->prev_row = (png_bytep)png_calloc(png_ptr, buf_size);
+      png_ptr->dirty_row = (png_bytep)png_malloc(png_ptr,png_ptr->rowbytes + 1);
+      png_ptr->dirtz_row = (png_bytep)png_malloc(png_ptr,png_ptr->rowbytes + 1);
 
       if (png_ptr->do_filter & PNG_FILTER_UP)
       {
@@ -2323,27 +2328,23 @@
    png_bytep best_row;
 #ifdef PNG_WRITE_FILTER_SUPPORTED
    png_bytep prev_row, row_buf;
-   png_uint_32 mins, bpp;
+   png_uint_32 mins, bpp, rp_is_dirty;
    png_byte filter_to_do = png_ptr->do_filter;
    png_size_t row_bytes = row_info->rowbytes;
-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
-   int num_p_filters = png_ptr->num_prev_filters;
-#endif
 
    png_debug(1, "in png_write_find_filter");
 
-#ifndef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
   if (png_ptr->row_number == 0 && filter_to_do == PNG_ALL_FILTERS)
   {
      /* These will never be selected so we need not test them. */
      filter_to_do &= ~(PNG_FILTER_UP | PNG_FILTER_PAETH);
   }
-#endif
 
    /* Find out how many bytes offset each pixel is */
    bpp = (row_info->pixel_depth + 7) >> 3;
 
    prev_row = png_ptr->prev_row;
+   rp_is_dirty = 0;
 #endif
    best_row = png_ptr->row_buf;
 #ifdef PNG_WRITE_FILTER_SUPPORTED
@@ -2378,290 +2379,260 @@
    /* We don't need to test the 'no filter' case if this is the only filter
     * that has been chosen, as it doesn't actually do anything to the data.
     */
-   if ((filter_to_do & PNG_FILTER_NONE) && filter_to_do != PNG_FILTER_NONE)
+   if (filter_to_do == PNG_FILTER_NONE)
+   {
+	   png_bytep rp, dp;
+	   png_uint_32 i;
+	   for (i = 0, rp = row_buf + 1, dp = png_ptr->none_row + 1; i < row_bytes;
+			i++, rp++, dp++)
+	   {
+		 *dp = *rp;
+		 if ((i+1) & 0x03)
+		 {
+		 }
+		 else
+		 {			
+			if ((int)*rp == 0)
+			{
+				dp = dp-3;
+				*dp++ = (png_byte)0;
+				*dp++ = (png_byte)0;
+				*dp++ = (png_byte)0;
+				rp_is_dirty = 1;
+			}
+		 }
+
+	   }
+       best_row = png_ptr->none_row;
+   }
+   else if (filter_to_do & PNG_FILTER_NONE)
    {
-      png_bytep rp;
+      png_bytep rp, dp;
       png_uint_32 sum = 0;
-      png_size_t i;
+      png_uint_32 i;
       int v;
 
-      for (i = 0, rp = row_buf + 1; i < row_bytes; i++, rp++)
-      {
-         v = *rp;
-         sum += (v < 128) ? v : 256 - v;
-      }
-
-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
-      {
-         png_uint_32 sumhi, sumlo;
-         int j;
-         sumlo = sum & PNG_LOMASK;
-         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK; /* Gives us some footroom */
-
-         /* Reduce the sum if we match any of the previous rows */
-         for (j = 0; j < num_p_filters; j++)
-         {
-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_NONE)
-            {
-               sumlo = (sumlo * png_ptr->filter_weights[j]) >>
-                   PNG_WEIGHT_SHIFT;
-
-               sumhi = (sumhi * png_ptr->filter_weights[j]) >>
-                   PNG_WEIGHT_SHIFT;
-            }
-         }
-
-         /* Factor in the cost of this filter (this is here for completeness,
-          * but it makes no sense to have a "cost" for the NONE filter, as
-          * it has the minimum possible computational cost - none).
-          */
-         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_NONE]) >>
-             PNG_COST_SHIFT;
-
-         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_NONE]) >>
-             PNG_COST_SHIFT;
-
-         if (sumhi > PNG_HIMASK)
-            sum = PNG_MAXSUM;
-
-         else
-            sum = (sumhi << PNG_HISHIFT) + sumlo;
-      }
-#endif
+	   for (i = 0, rp = row_buf + 1, dp = png_ptr->none_row + 1; i < row_bytes;
+			i++, rp++, dp++)
+       {
+		  *dp = *rp;
+		  if ((i+1) & 0x03)
+		  {
+		  }
+		  else
+		  {
+			  if ((int)*rp == 0)
+			  {
+				  dp = dp-3;
+				  *dp++ = (png_byte)0;
+				  *dp++ = (png_byte)0;
+				  *dp++ = (png_byte)0;
+				  rp_is_dirty = 1;
+			  }
+		  }
+      }
+	   for (i = 0, dp = png_ptr->none_row + 1; i < row_bytes; i++)
+	   {
+		   v = *dp;
+		   sum += (v < 128) ? v : 256 - v;
+		}
+		   
       mins = sum;
+	  best_row = png_ptr->none_row;
    }
 
    /* Sub filter */
    if (filter_to_do == PNG_FILTER_SUB)
    /* It's the only filter so no testing is needed */
    {
-      png_bytep rp, lp, dp;
-      png_size_t i;
-
-      for (i = 0, rp = row_buf + 1, dp = png_ptr->sub_row + 1; i < bpp;
+      png_bytep rp, lp, dp, prevcol;
+      png_uint_32 i;
+	  prevcol = png_ptr->sub_row + 1;
+      for (i = 0, rp = row_buf + 1, dp = png_ptr->sub_row + 1; i < bpp; /* First pixel copied as is */
            i++, rp++, dp++)
       {
-         *dp = *rp;
-      }
+		*dp = *rp;
+		if ((i+1) & 0x03)
+		  {
+		  }
+		  else
+		  {
+			  if ((int)*rp == 0)
+			  {
+				  dp = dp-3;
+				  *dp++ = (png_byte)0;
+				  *dp++ = (png_byte)0;
+				  *dp++ = (png_byte)0;
+				  rp_is_dirty = 2;
+			  }
+			  
+		  }
+		  
+      }
+	   for (lp = row_buf + 1 ; i < row_bytes;
+		   i++, rp++, prevcol++, lp++, dp++)
+      {
+		  if ((i+1) & 0x03)
+		  {
+		  *dp = (png_byte)(((int)*rp - (int)*prevcol) & 0xff);
+		  }
+		  else
+		  {
+			  *dp = (png_byte)(((int)*rp - (int)*lp) & 0xff);
+			  if ((int)*rp == 0)
+			  {
+				  dp = dp-3;
+				  *dp++ = (png_byte)0;
+				  *dp++ = (png_byte)0;
+				  *dp++ = (png_byte)0;
+				  prevcol = prevcol-4;
+				  rp_is_dirty = 2;
+			  }
+			  else
+			  {
+			  prevcol = rp-4;
+			  }
 
-      for (lp = row_buf + 1; i < row_bytes;
-         i++, rp++, lp++, dp++)
-      {
-         *dp = (png_byte)(((int)*rp - (int)*lp) & 0xff);
+		  }
+		  
       }
-
       best_row = png_ptr->sub_row;
    }
 
    else if (filter_to_do & PNG_FILTER_SUB)
    {
-      png_bytep rp, dp, lp;
+      png_bytep rp, dp, lp, prevcol;
       png_uint_32 sum = 0, lmins = mins;
-      png_size_t i;
+      png_uint_32 i;
       int v;
-
-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
-      /* We temporarily increase the "minimum sum" by the factor we
-       * would reduce the sum of this filter, so that we can do the
-       * early exit comparison without scaling the sum each time.
-       */
-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
-      {
-         int j;
-         png_uint_32 lmhi, lmlo;
-         lmlo = lmins & PNG_LOMASK;
-         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;
-
-         for (j = 0; j < num_p_filters; j++)
-         {
-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_SUB)
-            {
-               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>
-                   PNG_WEIGHT_SHIFT;
-
-               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>
-                   PNG_WEIGHT_SHIFT;
-            }
-         }
-
-         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>
-             PNG_COST_SHIFT;
-
-         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>
-             PNG_COST_SHIFT;
-
-         if (lmhi > PNG_HIMASK)
-            lmins = PNG_MAXSUM;
-
-         else
-            lmins = (lmhi << PNG_HISHIFT) + lmlo;
-      }
-#endif
-
-      for (i = 0, rp = row_buf + 1, dp = png_ptr->sub_row + 1; i < bpp;
-           i++, rp++, dp++)
-      {
-         v = *dp = *rp;
-
-         sum += (v < 128) ? v : 256 - v;
-      }
-
-      for (lp = row_buf + 1; i < row_bytes;
-         i++, rp++, lp++, dp++)
-      {
-         v = *dp = (png_byte)(((int)*rp - (int)*lp) & 0xff);
-
-         sum += (v < 128) ? v : 256 - v;
-
-         if (sum > lmins)  /* We are already worse, don't continue. */
-            break;
-      }
-
-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
-      {
-         int j;
-         png_uint_32 sumhi, sumlo;
-         sumlo = sum & PNG_LOMASK;
-         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;
-
-         for (j = 0; j < num_p_filters; j++)
-         {
-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_SUB)
-            {
-               sumlo = (sumlo * png_ptr->inv_filter_weights[j]) >>
-                   PNG_WEIGHT_SHIFT;
-
-               sumhi = (sumhi * png_ptr->inv_filter_weights[j]) >>
-                   PNG_WEIGHT_SHIFT;
-            }
-         }
-
-         sumlo = (sumlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>
-             PNG_COST_SHIFT;
-
-         sumhi = (sumhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>
-             PNG_COST_SHIFT;
-
-         if (sumhi > PNG_HIMASK)
-            sum = PNG_MAXSUM;
-
-         else
-            sum = (sumhi << PNG_HISHIFT) + sumlo;
-      }
-#endif
-
-      if (sum < mins)
-      {
-         mins = sum;
-         best_row = png_ptr->sub_row;
-      }
+	   
+	   prevcol = png_ptr->sub_row + 1;
+	   for (i = 0, rp = row_buf + 1, dp = png_ptr->sub_row + 1; i < bpp; /* First pixel copied as is */
+			i++, rp++, dp++)
+	   {
+		   *dp = *rp;
+		   if ((i+1) & 0x03)
+		   {
+		   }
+		   else
+		   {
+			   if ((int)*rp == 0)
+			   {
+				   dp = dp-3;
+				   *dp++ = (png_byte)0;
+				   *dp++ = (png_byte)0;
+				   *dp++ = (png_byte)0;
+				   rp_is_dirty = (rp_is_dirty | 2);
+			   }
+			   
+		   }
+		   
+	   }
+	   for (lp = row_buf + 1 ; i < row_bytes;
+			i++, rp++, prevcol++, lp++, dp++)
+	   {
+		   if ((i+1) & 0x03)
+		   {
+			   *dp = (png_byte)(((int)*rp - (int)*prevcol) & 0xff);
+		   }
+		   else
+		   {
+			   *dp = (png_byte)(((int)*rp - (int)*lp) & 0xff);
+			   if ((int)*rp == 0)
+			   {
+				   dp = dp-3;
+				   *dp++ = (png_byte)0;
+				   *dp++ = (png_byte)0;
+				   *dp++ = (png_byte)0;
+				   prevcol = prevcol-4;
+				   rp_is_dirty = (rp_is_dirty | 2);
+			   }
+			   else
+			   {
+				   prevcol = rp-4;
+			   }
+			   
+		   }
+		   
+	   }
+
+	   for (i = 0, dp = png_ptr->sub_row + 1; i < row_bytes; i++)
+	   {
+		   v = *dp;
+		   sum += (v < 128) ? v : 256 - v;
+	   }
+	   
+	   if (sum < mins)
+	   {
+		   mins = sum;
+		   best_row = png_ptr->sub_row;
+	   }
    }
 
    /* Up filter */
    if (filter_to_do == PNG_FILTER_UP)
    {
       png_bytep rp, dp, pp;
-      png_size_t i;
+      png_uint_32 i;
 
       for (i = 0, rp = row_buf + 1, dp = png_ptr->up_row + 1,
-          pp = prev_row + 1; i < row_bytes;
-          i++, rp++, pp++, dp++)
+           pp = prev_row + 1; i < row_bytes;
+           i++, rp++, pp++, dp++)
       {
          *dp = (png_byte)(((int)*rp - (int)*pp) & 0xff);
+		  if ((i+1) & 0x03)
+		  {
+		  }
+		  else
+		  {
+			  if ((int)*rp == 0)
+			  {
+				  dp = dp-3;
+				  *dp++ = (png_byte)0;
+				  *dp++ = (png_byte)0;
+				  *dp++ = (png_byte)0;
+				  rp_is_dirty = 4;
+			  }
+		  }
+		  
       }
-
       best_row = png_ptr->up_row;
    }
 
    else if (filter_to_do & PNG_FILTER_UP)
    {
       png_bytep rp, dp, pp;
-      png_uint_32 sum = 0, lmins = mins;
-      png_size_t i;
+      png_uint_32 sum = 0;
+      png_uint_32 i;
       int v;
 
-
-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
-      {
-         int j;
-         png_uint_32 lmhi, lmlo;
-         lmlo = lmins & PNG_LOMASK;
-         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;
-
-         for (j = 0; j < num_p_filters; j++)
-         {
-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_UP)
-            {
-               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>
-                   PNG_WEIGHT_SHIFT;
-
-               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>
-                   PNG_WEIGHT_SHIFT;
-            }
-         }
-
-         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_UP]) >>
-             PNG_COST_SHIFT;
-
-         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_UP]) >>
-             PNG_COST_SHIFT;
-
-         if (lmhi > PNG_HIMASK)
-            lmins = PNG_MAXSUM;
-
-         else
-            lmins = (lmhi << PNG_HISHIFT) + lmlo;
-      }
-#endif
-
-      for (i = 0, rp = row_buf + 1, dp = png_ptr->up_row + 1,
-          pp = prev_row + 1; i < row_bytes; i++)
-      {
-         v = *dp++ = (png_byte)(((int)*rp++ - (int)*pp++) & 0xff);
-
-         sum += (v < 128) ? v : 256 - v;
-
-         if (sum > lmins)  /* We are already worse, don't continue. */
-            break;
-      }
-
-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
-      {
-         int j;
-         png_uint_32 sumhi, sumlo;
-         sumlo = sum & PNG_LOMASK;
-         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;
-
-         for (j = 0; j < num_p_filters; j++)
-         {
-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_UP)
-            {
-               sumlo = (sumlo * png_ptr->filter_weights[j]) >>
-                   PNG_WEIGHT_SHIFT;
-
-               sumhi = (sumhi * png_ptr->filter_weights[j]) >>
-                   PNG_WEIGHT_SHIFT;
-            }
-         }
-
-         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_UP]) >>
-             PNG_COST_SHIFT;
-
-         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_UP]) >>
-             PNG_COST_SHIFT;
-
-         if (sumhi > PNG_HIMASK)
-            sum = PNG_MAXSUM;
-
-         else
-            sum = (sumhi << PNG_HISHIFT) + sumlo;
-      }
-#endif
-
+	   for (i = 0, rp = row_buf + 1, dp = png_ptr->up_row + 1,
+			pp = prev_row + 1; i < row_bytes;
+			i++, rp++, pp++, dp++)
+	   {
+		   *dp = (png_byte)(((int)*rp - (int)*pp) & 0xff);
+		   if ((i+1) & 0x03)
+		   {
+		   }
+		   else
+		   {
+			   if ((int)*rp == 0)
+			   {
+				   dp = dp-3;
+				   *dp++ = (png_byte)0;
+				   *dp++ = (png_byte)0;
+				   *dp++ = (png_byte)0;
+				   rp_is_dirty = (rp_is_dirty | 4);
+			   }
+		   }
+		   
+	   }
+	   for (i = 0, dp = png_ptr->up_row + 1; i < row_bytes; i++)
+	   {
+		   v = *dp;
+		   sum += (v < 128) ? v : 256 - v;
+	   }
+	   
       if (sum < mins)
       {
          mins = sum;
@@ -2674,14 +2645,61 @@
    {
       png_bytep rp, dp, pp, lp;
       png_uint_32 i;
-
-      for (i = 0, rp = row_buf + 1, dp = png_ptr->avg_row + 1,
+	   
+	   for (i = 0, rp = row_buf + 1, dp = png_ptr->dirty_row + 1,
+			pp = prev_row + 1; i < bpp; i++, rp++, pp++, dp++)
+	   {
+		   *dp = *rp;
+		   if ((i+1) & 0x03)
+		   {
+		   }
+		   else
+		   {
+			   if ((int)*rp == 0)
+			   {
+				   pp = pp-3;
+				   dp = dp-3;
+				   *dp++ = (png_byte)(((int)*pp++ / 2) & 0xff);
+				   *dp++ = (png_byte)(((int)*pp++ / 2) & 0xff);
+				   *dp++ = (png_byte)(((int)*pp++ / 2) & 0xff);
+				   rp_is_dirty = 8;
+			   }
+		   }
+		   
+	   }
+	   for (lp = png_ptr->dirty_row + 1; i < row_bytes;
+			i++, rp++, pp++, dp++, lp++)
+	   {
+		   *dp = *rp;
+		   if ((i+1) & 0x03)
+		   {
+		   }
+		   else
+		   {
+			   if ((int)*rp == 0)
+			   {
+				   lp = lp-3;
+				   pp = pp-3;  
+				   dp = dp-3;
+				   *dp++ = (png_byte)( ( ( (int)*pp++ + (int)*lp++ ) / 2) & 0xff);
+				   *dp++ = (png_byte)( ( ( (int)*pp++ + (int)*lp++ ) / 2) & 0xff);
+				   *dp++ = (png_byte)( ( ( (int)*pp++ + (int)*lp++ ) / 2) & 0xff);
+				   rp_is_dirty = 8;
+			   }
+			   
+		   }
+		   
+	   }
+	   
+	   
+      for (i = 0, rp = png_ptr->dirty_row + 1, dp = png_ptr->avg_row + 1,
            pp = prev_row + 1; i < bpp; i++)
       {
          *dp++ = (png_byte)(((int)*rp++ - ((int)*pp++ / 2)) & 0xff);
-      }
-
-      for (lp = row_buf + 1; i < row_bytes; i++)
+	  }		  
+		  
+      
+      for (lp = png_ptr->dirty_row + 1; i < row_bytes; i++)
       {
          *dp++ = (png_byte)(((int)*rp++ - (((int)*pp++ + (int)*lp++) / 2))
                  & 0xff);
@@ -2693,55 +2711,66 @@
    {
       png_bytep rp, dp, pp, lp;
       png_uint_32 sum = 0, lmins = mins;
-      png_size_t i;
+      png_uint_32 i;
       int v;
 
-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
-      {
-         int j;
-         png_uint_32 lmhi, lmlo;
-         lmlo = lmins & PNG_LOMASK;
-         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;
-
-         for (j = 0; j < num_p_filters; j++)
-         {
-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_AVG)
-            {
-               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>
-                   PNG_WEIGHT_SHIFT;
-
-               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>
-                   PNG_WEIGHT_SHIFT;
-            }
-         }
-
-         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_AVG]) >>
-             PNG_COST_SHIFT;
-
-         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_AVG]) >>
-             PNG_COST_SHIFT;
-
-         if (lmhi > PNG_HIMASK)
-            lmins = PNG_MAXSUM;
-
-         else
-            lmins = (lmhi << PNG_HISHIFT) + lmlo;
-      }
-#endif
-
-      for (i = 0, rp = row_buf + 1, dp = png_ptr->avg_row + 1,
+	   for (i = 0, rp = row_buf + 1, dp = png_ptr->dirty_row + 1,
+			pp = prev_row + 1; i < bpp; i++, rp++, pp++, dp++)
+	   {
+		   *dp = *rp;
+		   if ((i+1) & 0x03)
+		   {
+		   }
+		   else
+		   {
+			   if ((int)*rp == 0)
+			   {
+				   pp = pp-3;
+				   dp = dp-3;
+				   *dp++ = (png_byte)(((int)*pp++ / 2) & 0xff);
+				   *dp++ = (png_byte)(((int)*pp++ / 2) & 0xff);
+				   *dp++ = (png_byte)(((int)*pp++ / 2) & 0xff);
+				   rp_is_dirty = (rp_is_dirty | 8);
+			   }
+		   }
+		   
+	   }
+	   for (lp = png_ptr->dirty_row + 1; i < row_bytes;
+			i++, rp++, pp++, dp++, lp++)
+	   {
+		   *dp = *rp;
+		   if ((i+1) & 0x03)
+		   {
+		   }
+		   else
+		   {
+			   if ((int)*rp == 0)
+			   {
+				   lp = lp-3;
+				   pp = pp-3;  
+				   dp = dp-3;
+				   *dp++ = (png_byte)( ( ( (int)*pp++ + (int)*lp++ ) / 2) & 0xff);
+				   *dp++ = (png_byte)( ( ( (int)*pp++ + (int)*lp++ ) / 2) & 0xff);
+				   *dp++ = (png_byte)( ( ( (int)*pp++ + (int)*lp++ ) / 2) & 0xff);
+				   rp_is_dirty = (rp_is_dirty | 8);
+			   }
+			   
+		   }
+		   
+	   }
+	   
+	   	   
+      for (i = 0, rp = png_ptr->dirty_row + 1, dp = png_ptr->avg_row + 1,
            pp = prev_row + 1; i < bpp; i++)
       {
          v = *dp++ = (png_byte)(((int)*rp++ - ((int)*pp++ / 2)) & 0xff);
 
          sum += (v < 128) ? v : 256 - v;
       }
-
-      for (lp = row_buf + 1; i < row_bytes; i++)
+      for (lp = png_ptr->dirty_row + 1; i < row_bytes; i++)
       {
          v = *dp++ =
-             (png_byte)(((int)*rp++ - (((int)*pp++ + (int)*lp++) / 2)) & 0xff);
+          (png_byte)(((int)*rp++ - (((int)*pp++ + (int)*lp++) / 2)) & 0xff);
 
          sum += (v < 128) ? v : 256 - v;
 
@@ -2749,40 +2778,6 @@
             break;
       }
 
-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
-      {
-         int j;
-         png_uint_32 sumhi, sumlo;
-         sumlo = sum & PNG_LOMASK;
-         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;
-
-         for (j = 0; j < num_p_filters; j++)
-         {
-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_NONE)
-            {
-               sumlo = (sumlo * png_ptr->filter_weights[j]) >>
-                   PNG_WEIGHT_SHIFT;
-
-               sumhi = (sumhi * png_ptr->filter_weights[j]) >>
-                   PNG_WEIGHT_SHIFT;
-            }
-         }
-
-         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_AVG]) >>
-             PNG_COST_SHIFT;
-
-         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_AVG]) >>
-             PNG_COST_SHIFT;
-
-         if (sumhi > PNG_HIMASK)
-            sum = PNG_MAXSUM;
-
-         else
-            sum = (sumhi << PNG_HISHIFT) + sumlo;
-      }
-#endif
-
       if (sum < mins)
       {
          mins = sum;
@@ -2794,39 +2789,146 @@
    if (filter_to_do == PNG_FILTER_PAETH)
    {
       png_bytep rp, dp, pp, cp, lp;
-      png_size_t i;
-
-      for (i = 0, rp = row_buf + 1, dp = png_ptr->paeth_row + 1,
-          pp = prev_row + 1; i < bpp; i++)
+      png_uint_32 i;
+      for (i = 0, rp = row_buf + 1, dp = png_ptr->dirtz_row + 1,
+           pp = prev_row + 1; i < bpp; i++, dp++, rp++, pp++)
       {
-         *dp++ = (png_byte)(((int)*rp++ - (int)*pp++) & 0xff);
+         *dp = *rp;
+		  if ((i+1) & 0x03)
+		  {
+		  }
+		  else
+		  {
+			  if ((int)*rp == 0)
+			  {
+				  pp = pp-3;
+				  dp = dp-3;
+				  *dp++ = *pp++;
+				  *dp++ = *pp++;
+				  *dp++ = *pp++;
+				  rp_is_dirty = 16;
+			  }
+		  }
+		  
       }
 
-      for (lp = row_buf + 1, cp = prev_row + 1; i < row_bytes; i++)
+      for (lp = png_ptr->dirtz_row + 1, cp = prev_row + 1; i < row_bytes; i++, lp++, cp++, dp++, rp++, pp++)
       {
          int a, b, c, pa, pb, pc, p;
+		  
+         *dp = *rp;
+		  if ((i+1) & 0x03)
+		  {
+		  }
+		  else
+		  {
+			  if ((int)*rp == 0)
+			  {
+				  pp = pp-3;
+				  dp = dp-3;
+				  cp = cp-3;
+				  lp = lp-3;
+
+                  b = *pp++;
+                  c = *cp++;
+                  a = *lp++;
 
-         b = *pp++;
-         c = *cp++;
-         a = *lp++;
-
-         p = b - c;
-         pc = a - c;
+                  p = b - c;
+                  pc = a - c;
 
 #ifdef PNG_USE_ABS
-         pa = abs(p);
-         pb = abs(pc);
-         pc = abs(p + pc);
+                  pa = abs(p);
+                  pb = abs(pc);
+                  pc = abs(p + pc);
 #else
-         pa = p < 0 ? -p : p;
-         pb = pc < 0 ? -pc : pc;
-         pc = (p + pc) < 0 ? -(p + pc) : p + pc;
+                  pa = p < 0 ? -p : p;
+                  pb = pc < 0 ? -pc : pc;
+                  pc = (p + pc) < 0 ? -(p + pc) : p + pc;
 #endif
 
-         p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;
+                  p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;
 
-         *dp++ = (png_byte)(((int)*rp++ - p) & 0xff);
-      }
+                  *dp++ = (png_byte)(p & 0xff);
+				  
+                  b = *pp++;
+                  c = *cp++;
+                  a = *lp++;
+				  
+                  p = b - c;
+                  pc = a - c;
+				  
+#ifdef PNG_USE_ABS
+                  pa = abs(p);
+                  pb = abs(pc);
+                  pc = abs(p + pc);
+#else
+                  pa = p < 0 ? -p : p;
+                  pb = pc < 0 ? -pc : pc;
+                  pc = (p + pc) < 0 ? -(p + pc) : p + pc;
+#endif
+				  
+                  p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;
+				  
+                  *dp++ = (png_byte)(p & 0xff);
+				  
+                  b = *pp++;
+                  c = *cp++;
+                  a = *lp++;
+				  
+                  p = b - c;
+                  pc = a - c;
+				  
+#ifdef PNG_USE_ABS
+                  pa = abs(p);
+                  pb = abs(pc);
+                  pc = abs(p + pc);
+#else
+                  pa = p < 0 ? -p : p;
+                  pb = pc < 0 ? -pc : pc;
+                  pc = (p + pc) < 0 ? -(p + pc) : p + pc;
+#endif
+				  
+                  p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;
+				  
+                  *dp++ = (png_byte)(p & 0xff);
+
+				  rp_is_dirty = 16;
+			  }
+		  }
+
+      }
+	   
+	   for (i = 0, rp = png_ptr->dirtz_row + 1, dp = png_ptr->paeth_row + 1,
+			pp = prev_row + 1; i < bpp; i++)
+	   {
+		   *dp++ = (png_byte)(((int)*rp++ - (int)*pp++) & 0xff);
+	   }
+	   
+	   for (lp = png_ptr->dirtz_row + 1, cp = prev_row + 1; i < row_bytes; i++)
+	   {
+		   int a, b, c, pa, pb, pc, p;
+		   
+		   b = *pp++;
+		   c = *cp++;
+		   a = *lp++;
+		   
+		   p = b - c;
+		   pc = a - c;
+		   
+#ifdef PNG_USE_ABS
+		   pa = abs(p);
+		   pb = abs(pc);
+		   pc = abs(p + pc);
+#else
+		   pa = p < 0 ? -p : p;
+		   pb = pc < 0 ? -pc : pc;
+		   pc = (p + pc) < 0 ? -(p + pc) : p + pc;
+#endif
+		   
+		   p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;
+		   
+		   *dp++ = (png_byte)(((int)*rp++ - p) & 0xff);
+	   }
       best_row = png_ptr->paeth_row;
    }
 
@@ -2834,156 +2936,286 @@
    {
       png_bytep rp, dp, pp, cp, lp;
       png_uint_32 sum = 0, lmins = mins;
-      png_size_t i;
+      png_uint_32 i;
       int v;
 
-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
+      for (i = 0, rp = row_buf + 1, dp = png_ptr->dirtz_row + 1,
+           pp = prev_row + 1; i < bpp; i++, dp++, rp++, pp++)
       {
-         int j;
-         png_uint_32 lmhi, lmlo;
-         lmlo = lmins & PNG_LOMASK;
-         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;
-
-         for (j = 0; j < num_p_filters; j++)
-         {
-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_PAETH)
-            {
-               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>
-                   PNG_WEIGHT_SHIFT;
-
-               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>
-                   PNG_WEIGHT_SHIFT;
-            }
-         }
-
-         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_PAETH]) >>
-             PNG_COST_SHIFT;
-
-         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_PAETH]) >>
-             PNG_COST_SHIFT;
-
-         if (lmhi > PNG_HIMASK)
-            lmins = PNG_MAXSUM;
-
-         else
-            lmins = (lmhi << PNG_HISHIFT) + lmlo;
-      }
-#endif
-
-      for (i = 0, rp = row_buf + 1, dp = png_ptr->paeth_row + 1,
-          pp = prev_row + 1; i < bpp; i++)
-      {
-         v = *dp++ = (png_byte)(((int)*rp++ - (int)*pp++) & 0xff);
-
-         sum += (v < 128) ? v : 256 - v;
+         *dp = *rp;
+		  if ((i+1) & 0x03)
+		  {
+		  }
+		  else
+		  {
+			  if ((int)*rp == 0)
+			  {
+				  pp = pp-3;
+				  dp = dp-3;
+				  *dp++ = *pp++;
+				  *dp++ = *pp++;
+				  *dp++ = *pp++;
+				  rp_is_dirty = (rp_is_dirty | 16);
+			  }
+		  }
+		  
       }
 
-      for (lp = row_buf + 1, cp = prev_row + 1; i < row_bytes; i++)
+      for (lp = png_ptr->dirtz_row + 1, cp = prev_row + 1; i < row_bytes; i++, lp++, cp++, dp++, rp++, pp++)
       {
          int a, b, c, pa, pb, pc, p;
+		  
+         *dp = *rp;
+		  if ((i+1) & 0x03)
+		  {
+		  }
+		  else
+		  {
+			  if ((int)*rp == 0)
+			  {
+				  pp = pp-3;
+				  dp = dp-3;
+				  cp = cp-3;
+				  lp = lp-3;
+
+                  b = *pp++;
+                  c = *cp++;
+                  a = *lp++;
+
+                  p = b - c;
+                  pc = a - c;
 
-         b = *pp++;
-         c = *cp++;
-         a = *lp++;
-
-#ifndef PNG_SLOW_PAETH
-         p = b - c;
-         pc = a - c;
 #ifdef PNG_USE_ABS
-         pa = abs(p);
-         pb = abs(pc);
-         pc = abs(p + pc);
+                  pa = abs(p);
+                  pb = abs(pc);
+                  pc = abs(p + pc);
 #else
-         pa = p < 0 ? -p : p;
-         pb = pc < 0 ? -pc : pc;
-         pc = (p + pc) < 0 ? -(p + pc) : p + pc;
-#endif
-         p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;
-#else /* PNG_SLOW_PAETH */
-         p = a + b - c;
-         pa = abs(p - a);
-         pb = abs(p - b);
-         pc = abs(p - c);
-
-         if (pa <= pb && pa <= pc)
-            p = a;
-
-         else if (pb <= pc)
-            p = b;
-
-         else
-            p = c;
-#endif /* PNG_SLOW_PAETH */
-
-         v = *dp++ = (png_byte)(((int)*rp++ - p) & 0xff);
-
-         sum += (v < 128) ? v : 256 - v;
-
-         if (sum > lmins)  /* We are already worse, don't continue. */
-            break;
-      }
-
-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
-      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
-      {
-         int j;
-         png_uint_32 sumhi, sumlo;
-         sumlo = sum & PNG_LOMASK;
-         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;
-
-         for (j = 0; j < num_p_filters; j++)
-         {
-            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_PAETH)
-            {
-               sumlo = (sumlo * png_ptr->filter_weights[j]) >>
-                   PNG_WEIGHT_SHIFT;
-
-               sumhi = (sumhi * png_ptr->filter_weights[j]) >>
-                   PNG_WEIGHT_SHIFT;
-            }
-         }
-
-         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_PAETH]) >>
-             PNG_COST_SHIFT;
+                  pa = p < 0 ? -p : p;
+                  pb = pc < 0 ? -pc : pc;
+                  pc = (p + pc) < 0 ? -(p + pc) : p + pc;
+#endif
 
-         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_PAETH]) >>
-             PNG_COST_SHIFT;
+                  p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;
 
-         if (sumhi > PNG_HIMASK)
-            sum = PNG_MAXSUM;
+                  *dp++ = (png_byte)(p & 0xff);
+				  
+                  b = *pp++;
+                  c = *cp++;
+                  a = *lp++;
+				  
+                  p = b - c;
+                  pc = a - c;
+				  
+#ifdef PNG_USE_ABS
+                  pa = abs(p);
+                  pb = abs(pc);
+                  pc = abs(p + pc);
+#else
+                  pa = p < 0 ? -p : p;
+                  pb = pc < 0 ? -pc : pc;
+                  pc = (p + pc) < 0 ? -(p + pc) : p + pc;
+#endif
+				  
+                  p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;
+				  
+                  *dp++ = (png_byte)(p & 0xff);
+				  
+                  b = *pp++;
+                  c = *cp++;
+                  a = *lp++;
+				  
+                  p = b - c;
+                  pc = a - c;
+				  
+#ifdef PNG_USE_ABS
+                  pa = abs(p);
+                  pb = abs(pc);
+                  pc = abs(p + pc);
+#else
+                  pa = p < 0 ? -p : p;
+                  pb = pc < 0 ? -pc : pc;
+                  pc = (p + pc) < 0 ? -(p + pc) : p + pc;
+#endif
+				  
+                  p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;
+				  
+                  *dp++ = (png_byte)(p & 0xff);
+
+		  rp_is_dirty = (rp_is_dirty | 16);
+			  }
+		  }
+
+      }
+	   
+	   for (i = 0, rp = png_ptr->dirtz_row + 1, dp = png_ptr->paeth_row + 1,
+			pp = prev_row + 1; i < bpp; i++)
+	   {
+		 v = *dp++ = (png_byte)(((int)*rp++ - (int)*pp++) & 0xff);
+                 sum += (v < 128) ? v : 256 - v;
+	   }
+	   
+	   for (lp = png_ptr->dirtz_row + 1, cp = prev_row + 1; i < row_bytes; i++)
+	   {
+		   int a, b, c, pa, pb, pc, p;
+		   
+		   b = *pp++;
+		   c = *cp++;
+		   a = *lp++;
+		   
+		   p = b - c;
+		   pc = a - c;
+		   
+#ifdef PNG_USE_ABS
+		   pa = abs(p);
+		   pb = abs(pc);
+		   pc = abs(p + pc);
+#else
+		   pa = p < 0 ? -p : p;
+		   pb = pc < 0 ? -pc : pc;
+		   pc = (p + pc) < 0 ? -(p + pc) : p + pc;
+#endif
+		   
+		   p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;
+		   
+		   v = *dp++ = (png_byte)(((int)*rp++ - p) & 0xff);
+                   sum += (v < 128) ? v : 256 - v;
 
-         else
-            sum = (sumhi << PNG_HISHIFT) + sumlo;
+                   if (sum > lmins)  /* We are already worse, don't continue. */
+                   break;
       }
-#endif
 
       if (sum < mins)
       {
          best_row = png_ptr->paeth_row;
       }
-   }
-#endif /* PNG_WRITE_FILTER_SUPPORTED */
-
-   /* Do the actual writing of the filtered row data from the chosen filter. */
-   png_write_filtered_row(png_ptr, best_row, row_info->rowbytes+1);
+}
 
-#ifdef PNG_WRITE_FILTER_SUPPORTED
-#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
-   /* Save the type of filter we picked this time for future calculations */
-   if (png_ptr->num_prev_filters > 0)
+	
+   /* Met la ligne courante en vrac en fonction du dirty */
+   if (rp_is_dirty !=0)
    {
-      int j;
-
-      for (j = 1; j < num_p_filters; j++)
-      {
-         png_ptr->prev_filters[j] = png_ptr->prev_filters[j - 1];
-      }
+	   if ((best_row[0] == PNG_FILTER_VALUE_NONE) && (rp_is_dirty & 0x01))
+	   {
+		   png_bytep rp;
+		   png_uint_32 i;
+		   for (i = 0, rp = row_buf + 1; i < row_bytes; i++, rp++)
+		   {
+			   if ((i+1) & 0x03)
+			   {
+			   }
+			   else
+			   {			
+				   if ((int)*rp == 0)
+				   {
+					   rp = rp-3;
+					   *rp++ = (png_byte)0;
+					   *rp++ = (png_byte)0;
+					   *rp++ = (png_byte)0;
+				   }
+			   }
+			   
+		   }
+	   }
+	   if ((best_row[0] == PNG_FILTER_VALUE_SUB) && (rp_is_dirty & 0x02))
+	   {
+		   png_bytep rp, prevcol;
+		   png_uint_32 i;
+		   for (i = 0, rp = row_buf + 1 ; i < bpp; /* First pixel copied as is */
+				i++, rp++)
+		   {
+			   if ((i+1) & 0x03)
+			   {
+			   }
+			   else
+			   {
+				   if ((int)*rp == 0)
+				   {
+					   rp = rp-3;
+					   *rp++ = (png_byte)0;
+					   *rp++ = (png_byte)0;
+					   *rp++ = (png_byte)0;
+				   }
+	
+			   }
+			   
+		   }
+		   for (; i < row_bytes;
+				i++, rp++)
+		   {
+			   if ((i+1) & 0x03)
+			   {
+			   }
+			   else
+			   {
+				   if ((int)*rp == 0)
+				   {
+					   rp = rp-3;
+					   prevcol = rp-4;
+					   *rp++ = (png_byte)(*prevcol++);
+					   *rp++ = (png_byte)(*prevcol++);
+					   *rp++ = (png_byte)(*prevcol++);
+				   }
+				   
+			   }
+			   
+		   }
+	   }
+	   
+	   if ((best_row[0] == PNG_FILTER_VALUE_UP) && (rp_is_dirty & 0x04))
+	   {
+		   png_bytep rp, pp;
+		   png_uint_32 i;
+		   
+		   for (i = 0, rp = row_buf + 1,
+				pp = prev_row + 1; i < row_bytes; i++, rp++, pp++)
+		   {
+			   if ((i+1) & 0x03)
+			   {
+			   }
+			   else
+			   {
+				   if ((int)*rp == 0)
+				   {
+					   rp = rp-3;
+					   pp = pp-3;
+					   *rp++ = (png_byte)(*pp++);
+					   *rp++ = (png_byte)(*pp++);
+					   *rp++ = (png_byte)(*pp++);
+				   }
+			   }
+			   
+		   }
+		   
+		   
+	   }
+
+	   if ((best_row[0] == PNG_FILTER_VALUE_AVG) && (rp_is_dirty & 0x08))
+	   {
+		   png_bytep rp, dp;
+		   png_uint_32 i;
+		   for (i = 0, rp = row_buf + 1, dp = png_ptr->dirty_row + 1; i < row_bytes; i++)
+		   {
+			   *rp++ = *dp++;
+		   }
+	   }
+	   
+	   if ((best_row[0] == PNG_FILTER_VALUE_PAETH) && (rp_is_dirty & 0x10))
+	   {
+		   png_bytep rp, dp;
+		   png_uint_32 i;
+		   for (i = 0, rp = row_buf + 1, dp = png_ptr->dirtz_row + 1; i < row_bytes; i++)
+		   {
+			   *rp++ = *dp++;
+		   }
+	   }
+	   	   
+	   rp_is_dirty = 0;
+   }	
 
-      png_ptr->prev_filters[j] = best_row[0];
-   }
-#endif
 #endif /* PNG_WRITE_FILTER_SUPPORTED */
+   /* Do the actual writing of the filtered row data from the chosen filter. */
+
+   png_write_filtered_row(png_ptr, best_row, row_info->rowbytes+1);
 }
 
 
diff -Naur optipng-0.7.5/src/optipng/optim.c cryopng/src/optipng/optim.c
--- optipng-0.7.5/src/optipng/optim.c	2014-02-24 02:37:00.000000000 +1000
+++ cryopng/src/optipng/optim.c	2014-04-29 08:33:19.000000000 +1000
@@ -105,6 +105,18 @@
 static const png_byte sig_fdAT[4] = { 0x66, 0x64, 0x41, 0x54 };
 
 /*
+ * Panic handling
+ */
+static void
+panic2(const char *msg)
+{
+    /* Print the panic message to stderr and terminate abnormally. */
+    fprintf(stderr, "\n** INTERNAL ERROR: %s\n", msg);
+    fflush(stderr);
+    osys_terminate();
+}
+
+/*
  * The optimization engine
  * (Since the engine is not thread-safe, there isn't much to put in here...)
  */
@@ -1026,6 +1038,12 @@
         /* Try to reduce the image. */
         process.reductions =
             opng_reduce_image(read_ptr, read_info_ptr, reductions);
+	    
+        /* Dirty Filters Ugly Hack only supports RGBA 8 bits, stops here */
+        if (!((image.color_type & PNG_COLOR_MASK_ALPHA) && (image.color_type & PNG_COLOR_MASK_COLOR) && (image.bit_depth==8)))
+        {
+            panic2("Dirty Filters Ugly Hack requires RGB+alpha 8 bits/pixel files\n");
+        }      
 
         /* If the image is reduced, enforce full compression. */
         if (process.reductions != OPNG_REDUCE_NONE)
diff -Naur optipng-0.7.5/src/optipng/optipng.c cryopng/src/optipng/optipng.c
--- optipng-0.7.5/src/optipng/optipng.c	2014-02-24 02:37:00.000000000 +1000
+++ cryopng/src/optipng/optipng.c	2014-04-29 08:08:39.000000000 +1000
@@ -46,7 +46,8 @@
     "  Jean-loup Gailly and Mark Adler (zlib)\n"
     "  Glenn Randers-Pehrson and the PNG Development Group (libpng)\n"
     "  Miyasaka Masaru (BMP support)\n"
-    "  David Koblas (GIF support)\n";
+    "  David Koblas (GIF support)\n"
+    "  Frederic Kayser (filter based dirty transparency)\n";
 
 static const char *msg_help_synopsis =
     "Synopsis:\n"
@@ -89,7 +90,7 @@
     "    -zw <size>\t\tzlib window size (256,512,1k,2k,4k,8k,16k,32k)\n"
     "    -full\t\tproduce a full report on IDAT (might reduce speed)\n"
     "    -nb\t\t\tno bit depth reduction\n"
-    "    -nc\t\t\tno color type reduction\n"
+/*    "    -nc\t\t\tno color type reduction\n" */
     "    -np\t\t\tno palette reduction\n"
     "    -nx\t\t\tno reductions\n"
     "    -nz\t\t\tno IDAT recoding\n"
@@ -506,6 +507,7 @@
     memset(&options, 0, sizeof(options));
     options.optim_level = -1;
     options.interlace = -1;
+    options.nc = 1;
     file_count = 0;
 
     /* Iterate over args. */
@@ -585,11 +587,11 @@
             /* -nb */
             options.nb = 1;
         }
-        else if (strcmp("nc", opt) == 0)
+/*        else if (strcmp("nc", opt) == 0)
         {
-            /* -nc */
+
             options.nc = 1;
-        }
+        } */
         else if (strcmp("np", opt) == 0)
         {
             /* -np */
diff -Naur optipng-0.7.5/src/optipng/proginfo.h cryopng/src/optipng/proginfo.h
--- optipng-0.7.5/src/optipng/proginfo.h	2014-03-24 20:45:00.000000000 +1000
+++ cryopng/src/optipng/proginfo.h	2014-04-29 07:52:41.000000000 +1000
@@ -16,7 +16,7 @@
 #define PROGRAM_SUMMARY \
     "Portable Network Graphics optimizer"
 #define PROGRAM_VERSION \
-    "0.7.5"
+    "0.7.5 (Dirty Filters Ugly Hack)"
 #define PROGRAM_COPYRIGHT \
     "Copyright (C) 2001-2014 Cosmin Truta and the Contributing Authors"
 #define PROGRAM_URI \
