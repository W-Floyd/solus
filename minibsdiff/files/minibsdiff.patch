diff -Naur -U 5 bsdiff-4.3/AUTHORS.txt minibsdiff-master/AUTHORS.txt
--- bsdiff-4.3/AUTHORS.txt	1970-01-01 10:00:00.000000000 +1000
+++ minibsdiff-master/AUTHORS.txt	2014-04-15 13:49:58.000000000 +1000
@@ -0,0 +1,15 @@
+bsdiff was originally written by:
+
+  Colin Percival <cperciva [@at] freebsd [.dot] org>
+
+Current maintainer, target of blame:
+
+  Austin Seipp <aseipp [@at] pobox [.dot] com>
+
+People who contributed code, ideas or lively discussion include, in no
+particular order:
+
+  Tres Walsh <tres [.dot] walsh [@at] mnmlstc [dot] com>
+  Ray Cheung <ray [.dot] swc [@at] gmail [dot] com>
+
+If you're not mentioned above but would like to be, please contact me.
diff -Naur -U 5 bsdiff-4.3/bsdiff.1 minibsdiff-master/bsdiff.1
--- bsdiff-4.3/bsdiff.1	2005-08-17 08:05:40.000000000 +1000
+++ minibsdiff-master/bsdiff.1	1970-01-01 10:00:00.000000000 +1000
@@ -1,63 +0,0 @@
-.\"-
-.\" Copyright 2003-2005 Colin Percival
-.\" All rights reserved
-.\"
-.\" Redistribution and use in source and binary forms, with or without
-.\" modification, are permitted providing that the following conditions
-.\" are met:
-.\" 1. Redistributions of source code must retain the above copyright
-.\"    notice, this list of conditions and the following disclaimer.
-.\" 2. Redistributions in binary form must reproduce the above copyright
-.\"    notice, this list of conditions and the following disclaimer in the
-.\"    documentation and/or other materials provided with the distribution.
-.\"
-.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-.\" WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
-.\" DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
-.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
-.\" STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
-.\" IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-.\" POSSIBILITY OF SUCH DAMAGE.
-.\"
-.\" $FreeBSD: src/usr.bin/bsdiff/bsdiff/bsdiff.1,v 1.1 2005/08/06 01:59:05 cperciva Exp $
-.\"
-.Dd May 18, 2003
-.Dt BSDIFF 1
-.Os FreeBSD
-.Sh NAME
-.Nm bsdiff
-.Nd generate a patch between two binary files
-.Sh SYNOPSIS
-.Nm
-.Ao Ar oldfile Ac Ao Ar newfile Ac Ao Ar patchfile Ac
-.Sh DESCRIPTION
-.Nm
-compares
-.Ao Ar oldfile Ac
-to
-.Ao Ar newfile Ac
-and writes to
-.Ao Ar patchfile Ac
-a binary patch suitable for use by bspatch(1).
-When
-.Ao Ar oldfile Ac
-and
-.Ao Ar newfile Ac
-are two versions of an executable program, the
-patches produced are on average a factor of five smaller
-than those produced by any other binary patch tool known
-to the author.
-.Pp
-.Nm
-uses memory equal to 17 times the size of 
-.Ao Ar oldfile Ac ,
-and requires
-an absolute minimum working set size of 8 times the size of oldfile.
-.Sh SEE ALSO
-.Xr bspatch 1
-.Sh AUTHORS
-.An Colin Percival Aq cperciva@freebsd.org
diff -Naur -U 5 bsdiff-4.3/bsdiff.c minibsdiff-master/bsdiff.c
--- bsdiff-4.3/bsdiff.c	2005-08-17 08:13:52.000000000 +1000
+++ minibsdiff-master/bsdiff.c	2014-04-15 13:49:58.000000000 +1000
@@ -1,11 +1,12 @@
 /*-
+ * Copyright 2012-2013 Austin Seipp
  * Copyright 2003-2005 Colin Percival
  * All rights reserved
  *
  * Redistribution and use in source and binary forms, with or without
- * modification, are permitted providing that the following conditions 
+ * modification, are permitted providing that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer.
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
@@ -26,379 +27,347 @@
 
 #if 0
 __FBSDID("$FreeBSD: src/usr.bin/bsdiff/bsdiff/bsdiff.c,v 1.1 2005/08/06 01:59:05 cperciva Exp $");
 #endif
 
-#include <sys/types.h>
-
-#include <bzlib.h>
-#include <err.h>
-#include <fcntl.h>
-#include <stdio.h>
 #include <stdlib.h>
+#include <stdio.h>
 #include <string.h>
-#include <unistd.h>
+#include <sys/types.h>
+
+#include "bsdiff.h"
 
 #define MIN(x,y) (((x)<(y)) ? (x) : (y))
 
-static void split(off_t *I,off_t *V,off_t start,off_t len,off_t h)
+/* Header is
+   0  8       BSDIFF_CONFIG_MAGIC (see minibsdiff-config.h)
+   8  8       length of bzip2ed ctrl block
+   16 8       length of bzip2ed diff block
+   24 8       length of new file */
+/* File is
+   0  32      Header
+   32 ??      ctrl block
+   ?? ??      diff block
+   ?? ??      extra block */
+
+
+static void
+split(off_t *I,off_t *V,off_t start,off_t len,off_t h)
 {
-	off_t i,j,k,x,tmp,jj,kk;
+  off_t i,j,k,x,tmp,jj,kk;
 
-	if(len<16) {
-		for(k=start;k<start+len;k+=j) {
-			j=1;x=V[I[k]+h];
-			for(i=1;k+i<start+len;i++) {
-				if(V[I[k+i]+h]<x) {
-					x=V[I[k+i]+h];
-					j=0;
-				};
-				if(V[I[k+i]+h]==x) {
-					tmp=I[k+j];I[k+j]=I[k+i];I[k+i]=tmp;
-					j++;
-				};
-			};
-			for(i=0;i<j;i++) V[I[k+i]]=k+j-1;
-			if(j==1) I[k]=-1;
-		};
-		return;
-	};
-
-	x=V[I[start+len/2]+h];
-	jj=0;kk=0;
-	for(i=start;i<start+len;i++) {
-		if(V[I[i]+h]<x) jj++;
-		if(V[I[i]+h]==x) kk++;
-	};
-	jj+=start;kk+=jj;
-
-	i=start;j=0;k=0;
-	while(i<jj) {
-		if(V[I[i]+h]<x) {
-			i++;
-		} else if(V[I[i]+h]==x) {
-			tmp=I[i];I[i]=I[jj+j];I[jj+j]=tmp;
-			j++;
-		} else {
-			tmp=I[i];I[i]=I[kk+k];I[kk+k]=tmp;
-			k++;
-		};
-	};
-
-	while(jj+j<kk) {
-		if(V[I[jj+j]+h]==x) {
-			j++;
-		} else {
-			tmp=I[jj+j];I[jj+j]=I[kk+k];I[kk+k]=tmp;
-			k++;
-		};
-	};
+  if(len<16) {
+    for(k=start;k<start+len;k+=j) {
+      j=1;x=V[I[k]+h];
+      for(i=1;k+i<start+len;i++) {
+        if(V[I[k+i]+h]<x) {
+          x=V[I[k+i]+h];
+          j=0;
+        };
+        if(V[I[k+i]+h]==x) {
+          tmp=I[k+j];I[k+j]=I[k+i];I[k+i]=tmp;
+          j++;
+        };
+      };
+      for(i=0;i<j;i++) V[I[k+i]]=k+j-1;
+      if(j==1) I[k]=-1;
+    };
+    return;
+  };
+
+  x=V[I[start+len/2]+h];
+  jj=0;kk=0;
+  for(i=start;i<start+len;i++) {
+    if(V[I[i]+h]<x) jj++;
+    if(V[I[i]+h]==x) kk++;
+  };
+  jj+=start;kk+=jj;
+
+  i=start;j=0;k=0;
+  while(i<jj) {
+    if(V[I[i]+h]<x) {
+      i++;
+    } else if(V[I[i]+h]==x) {
+      tmp=I[i];I[i]=I[jj+j];I[jj+j]=tmp;
+      j++;
+    } else {
+      tmp=I[i];I[i]=I[kk+k];I[kk+k]=tmp;
+      k++;
+    };
+  };
+
+  while(jj+j<kk) {
+    if(V[I[jj+j]+h]==x) {
+      j++;
+    } else {
+      tmp=I[jj+j];I[jj+j]=I[kk+k];I[kk+k]=tmp;
+      k++;
+    };
+  };
 
-	if(jj>start) split(I,V,start,jj-start,h);
+  if(jj>start) split(I,V,start,jj-start,h);
 
-	for(i=0;i<kk-jj;i++) V[I[jj+i]]=kk-1;
-	if(jj==kk-1) I[jj]=-1;
+  for(i=0;i<kk-jj;i++) V[I[jj+i]]=kk-1;
+  if(jj==kk-1) I[jj]=-1;
 
-	if(start+len>kk) split(I,V,kk,start+len-kk,h);
+  if(start+len>kk) split(I,V,kk,start+len-kk,h);
 }
 
-static void qsufsort(off_t *I,off_t *V,u_char *old,off_t oldsize)
+static void
+qsufsort(off_t *I,off_t *V,u_char *old,off_t oldsize)
 {
-	off_t buckets[256];
-	off_t i,h,len;
+  off_t buckets[256];
+  off_t i,h,len;
 
-	for(i=0;i<256;i++) buckets[i]=0;
-	for(i=0;i<oldsize;i++) buckets[old[i]]++;
-	for(i=1;i<256;i++) buckets[i]+=buckets[i-1];
-	for(i=255;i>0;i--) buckets[i]=buckets[i-1];
-	buckets[0]=0;
-
-	for(i=0;i<oldsize;i++) I[++buckets[old[i]]]=i;
-	I[0]=oldsize;
-	for(i=0;i<oldsize;i++) V[i]=buckets[old[i]];
-	V[oldsize]=0;
-	for(i=1;i<256;i++) if(buckets[i]==buckets[i-1]+1) I[buckets[i]]=-1;
-	I[0]=-1;
-
-	for(h=1;I[0]!=-(oldsize+1);h+=h) {
-		len=0;
-		for(i=0;i<oldsize+1;) {
-			if(I[i]<0) {
-				len-=I[i];
-				i-=I[i];
-			} else {
-				if(len) I[i-len]=-len;
-				len=V[I[i]]+1-i;
-				split(I,V,i,len,h);
-				i+=len;
-				len=0;
-			};
-		};
-		if(len) I[i-len]=-len;
-	};
+  for(i=0;i<256;i++) buckets[i]=0;
+  for(i=0;i<oldsize;i++) buckets[old[i]]++;
+  for(i=1;i<256;i++) buckets[i]+=buckets[i-1];
+  for(i=255;i>0;i--) buckets[i]=buckets[i-1];
+  buckets[0]=0;
+
+  for(i=0;i<oldsize;i++) I[++buckets[old[i]]]=i;
+  I[0]=oldsize;
+  for(i=0;i<oldsize;i++) V[i]=buckets[old[i]];
+  V[oldsize]=0;
+  for(i=1;i<256;i++) if(buckets[i]==buckets[i-1]+1) I[buckets[i]]=-1;
+  I[0]=-1;
+
+  for(h=1;I[0]!=-(oldsize+1);h+=h) {
+    len=0;
+    for(i=0;i<oldsize+1;) {
+      if(I[i]<0) {
+        len-=I[i];
+        i-=I[i];
+      } else {
+        if(len) I[i-len]=-len;
+        len=V[I[i]]+1-i;
+        split(I,V,i,len,h);
+        i+=len;
+        len=0;
+      };
+    };
+    if(len) I[i-len]=-len;
+  };
 
-	for(i=0;i<oldsize+1;i++) I[V[i]]=i;
+  for(i=0;i<oldsize+1;i++) I[V[i]]=i;
 }
 
-static off_t matchlen(u_char *old,off_t oldsize,u_char *new,off_t newsize)
+static off_t
+matchlen(u_char *oldp,off_t oldsize,u_char *newp,off_t newsize)
 {
-	off_t i;
+  off_t i;
 
-	for(i=0;(i<oldsize)&&(i<newsize);i++)
-		if(old[i]!=new[i]) break;
+  for(i=0;(i<oldsize)&&(i<newsize);i++)
+    if(oldp[i]!=newp[i]) break;
 
-	return i;
+  return i;
 }
 
-static off_t search(off_t *I,u_char *old,off_t oldsize,
-		u_char *new,off_t newsize,off_t st,off_t en,off_t *pos)
+static off_t
+search(off_t *I,u_char *oldp,off_t oldsize,
+       u_char *newp,off_t newsize,off_t st,off_t en,off_t *pos)
 {
-	off_t x,y;
+  off_t x,y;
 
-	if(en-st<2) {
-		x=matchlen(old+I[st],oldsize-I[st],new,newsize);
-		y=matchlen(old+I[en],oldsize-I[en],new,newsize);
-
-		if(x>y) {
-			*pos=I[st];
-			return x;
-		} else {
-			*pos=I[en];
-			return y;
-		}
-	};
-
-	x=st+(en-st)/2;
-	if(memcmp(old+I[x],new,MIN(oldsize-I[x],newsize))<0) {
-		return search(I,old,oldsize,new,newsize,x,en,pos);
-	} else {
-		return search(I,old,oldsize,new,newsize,st,x,pos);
-	};
+  if(en-st<2) {
+    x=matchlen(oldp+I[st],oldsize-I[st],newp,newsize);
+    y=matchlen(oldp+I[en],oldsize-I[en],newp,newsize);
+
+    if(x>y) {
+      *pos=I[st];
+      return x;
+    } else {
+      *pos=I[en];
+      return y;
+    }
+  };
+
+  x=st+(en-st)/2;
+  if(memcmp(oldp+I[x],newp,MIN(oldsize-I[x],newsize))<0) {
+    return search(I,oldp,oldsize,newp,newsize,x,en,pos);
+  } else {
+    return search(I,oldp,oldsize,newp,newsize,st,x,pos);
+  };
 }
 
-static void offtout(off_t x,u_char *buf)
+static void
+offtout(off_t x,u_char *buf)
 {
-	off_t y;
+  off_t y;
 
-	if(x<0) y=-x; else y=x;
+  if(x<0) y=-x; else y=x;
 
-		buf[0]=y%256;y-=buf[0];
-	y=y/256;buf[1]=y%256;y-=buf[1];
-	y=y/256;buf[2]=y%256;y-=buf[2];
-	y=y/256;buf[3]=y%256;y-=buf[3];
-	y=y/256;buf[4]=y%256;y-=buf[4];
-	y=y/256;buf[5]=y%256;y-=buf[5];
-	y=y/256;buf[6]=y%256;y-=buf[6];
-	y=y/256;buf[7]=y%256;
+  buf[0]=y%256;y-=buf[0];
+  y=y/256;buf[1]=y%256;y-=buf[1];
+  y=y/256;buf[2]=y%256;y-=buf[2];
+  y=y/256;buf[3]=y%256;y-=buf[3];
+  y=y/256;buf[4]=y%256;y-=buf[4];
+  y=y/256;buf[5]=y%256;y-=buf[5];
+  y=y/256;buf[6]=y%256;y-=buf[6];
+  y=y/256;buf[7]=y%256;
 
-	if(x<0) buf[7]|=0x80;
+  if(x<0) buf[7]|=0x80;
+}
+
+off_t
+bsdiff_patchsize_max(off_t newsize, off_t oldsize)
+{
+  return newsize+oldsize+BSDIFF_PATCH_SLOP_SIZE;
 }
 
-int main(int argc,char *argv[])
+int bsdiff(u_char* oldp, off_t oldsize,
+           u_char* newp, off_t newsize,
+           u_char* patch, off_t patchsz)
 {
-	int fd;
-	u_char *old,*new;
-	off_t oldsize,newsize;
-	off_t *I,*V;
-	off_t scan,pos,len;
-	off_t lastscan,lastpos,lastoffset;
-	off_t oldscore,scsc;
-	off_t s,Sf,lenf,Sb,lenb;
-	off_t overlap,Ss,lens;
-	off_t i;
-	off_t dblen,eblen;
-	u_char *db,*eb;
-	u_char buf[8];
-	u_char header[32];
-	FILE * pf;
-	BZFILE * pfbz2;
-	int bz2err;
-
-	if(argc!=4) errx(1,"usage: %s oldfile newfile patchfile\n",argv[0]);
-
-	/* Allocate oldsize+1 bytes instead of oldsize bytes to ensure
-		that we never try to malloc(0) and get a NULL pointer */
-	if(((fd=open(argv[1],O_RDONLY,0))<0) ||
-		((oldsize=lseek(fd,0,SEEK_END))==-1) ||
-		((old=malloc(oldsize+1))==NULL) ||
-		(lseek(fd,0,SEEK_SET)!=0) ||
-		(read(fd,old,oldsize)!=oldsize) ||
-		(close(fd)==-1)) err(1,"%s",argv[1]);
-
-	if(((I=malloc((oldsize+1)*sizeof(off_t)))==NULL) ||
-		((V=malloc((oldsize+1)*sizeof(off_t)))==NULL)) err(1,NULL);
-
-	qsufsort(I,V,old,oldsize);
-
-	free(V);
-
-	/* Allocate newsize+1 bytes instead of newsize bytes to ensure
-		that we never try to malloc(0) and get a NULL pointer */
-	if(((fd=open(argv[2],O_RDONLY,0))<0) ||
-		((newsize=lseek(fd,0,SEEK_END))==-1) ||
-		((new=malloc(newsize+1))==NULL) ||
-		(lseek(fd,0,SEEK_SET)!=0) ||
-		(read(fd,new,newsize)!=newsize) ||
-		(close(fd)==-1)) err(1,"%s",argv[2]);
-
-	if(((db=malloc(newsize+1))==NULL) ||
-		((eb=malloc(newsize+1))==NULL)) err(1,NULL);
-	dblen=0;
-	eblen=0;
-
-	/* Create the patch file */
-	if ((pf = fopen(argv[3], "w")) == NULL)
-		err(1, "%s", argv[3]);
-
-	/* Header is
-		0	8	 "BSDIFF40"
-		8	8	length of bzip2ed ctrl block
-		16	8	length of bzip2ed diff block
-		24	8	length of new file */
-	/* File is
-		0	32	Header
-		32	??	Bzip2ed ctrl block
-		??	??	Bzip2ed diff block
-		??	??	Bzip2ed extra block */
-	memcpy(header,"BSDIFF40",8);
-	offtout(0, header + 8);
-	offtout(0, header + 16);
-	offtout(newsize, header + 24);
-	if (fwrite(header, 32, 1, pf) != 1)
-		err(1, "fwrite(%s)", argv[3]);
-
-	/* Compute the differences, writing ctrl as we go */
-	if ((pfbz2 = BZ2_bzWriteOpen(&bz2err, pf, 9, 0, 0)) == NULL)
-		errx(1, "BZ2_bzWriteOpen, bz2err = %d", bz2err);
-	scan=0;len=0;
-	lastscan=0;lastpos=0;lastoffset=0;
-	while(scan<newsize) {
-		oldscore=0;
-
-		for(scsc=scan+=len;scan<newsize;scan++) {
-			len=search(I,old,oldsize,new+scan,newsize-scan,
-					0,oldsize,&pos);
-
-			for(;scsc<scan+len;scsc++)
-			if((scsc+lastoffset<oldsize) &&
-				(old[scsc+lastoffset] == new[scsc]))
-				oldscore++;
-
-			if(((len==oldscore) && (len!=0)) || 
-				(len>oldscore+8)) break;
-
-			if((scan+lastoffset<oldsize) &&
-				(old[scan+lastoffset] == new[scan]))
-				oldscore--;
-		};
-
-		if((len!=oldscore) || (scan==newsize)) {
-			s=0;Sf=0;lenf=0;
-			for(i=0;(lastscan+i<scan)&&(lastpos+i<oldsize);) {
-				if(old[lastpos+i]==new[lastscan+i]) s++;
-				i++;
-				if(s*2-i>Sf*2-lenf) { Sf=s; lenf=i; };
-			};
-
-			lenb=0;
-			if(scan<newsize) {
-				s=0;Sb=0;
-				for(i=1;(scan>=lastscan+i)&&(pos>=i);i++) {
-					if(old[pos-i]==new[scan-i]) s++;
-					if(s*2-i>Sb*2-lenb) { Sb=s; lenb=i; };
-				};
-			};
-
-			if(lastscan+lenf>scan-lenb) {
-				overlap=(lastscan+lenf)-(scan-lenb);
-				s=0;Ss=0;lens=0;
-				for(i=0;i<overlap;i++) {
-					if(new[lastscan+lenf-overlap+i]==
-					   old[lastpos+lenf-overlap+i]) s++;
-					if(new[scan-lenb+i]==
-					   old[pos-lenb+i]) s--;
-					if(s>Ss) { Ss=s; lens=i+1; };
-				};
-
-				lenf+=lens-overlap;
-				lenb-=lens;
-			};
-
-			for(i=0;i<lenf;i++)
-				db[dblen+i]=new[lastscan+i]-old[lastpos+i];
-			for(i=0;i<(scan-lenb)-(lastscan+lenf);i++)
-				eb[eblen+i]=new[lastscan+lenf+i];
-
-			dblen+=lenf;
-			eblen+=(scan-lenb)-(lastscan+lenf);
-
-			offtout(lenf,buf);
-			BZ2_bzWrite(&bz2err, pfbz2, buf, 8);
-			if (bz2err != BZ_OK)
-				errx(1, "BZ2_bzWrite, bz2err = %d", bz2err);
-
-			offtout((scan-lenb)-(lastscan+lenf),buf);
-			BZ2_bzWrite(&bz2err, pfbz2, buf, 8);
-			if (bz2err != BZ_OK)
-				errx(1, "BZ2_bzWrite, bz2err = %d", bz2err);
-
-			offtout((pos-lenb)-(lastpos+lenf),buf);
-			BZ2_bzWrite(&bz2err, pfbz2, buf, 8);
-			if (bz2err != BZ_OK)
-				errx(1, "BZ2_bzWrite, bz2err = %d", bz2err);
-
-			lastscan=scan-lenb;
-			lastpos=pos-lenb;
-			lastoffset=pos-scan;
-		};
-	};
-	BZ2_bzWriteClose(&bz2err, pfbz2, 0, NULL, NULL);
-	if (bz2err != BZ_OK)
-		errx(1, "BZ2_bzWriteClose, bz2err = %d", bz2err);
-
-	/* Compute size of compressed ctrl data */
-	if ((len = ftello(pf)) == -1)
-		err(1, "ftello");
-	offtout(len-32, header + 8);
-
-	/* Write compressed diff data */
-	if ((pfbz2 = BZ2_bzWriteOpen(&bz2err, pf, 9, 0, 0)) == NULL)
-		errx(1, "BZ2_bzWriteOpen, bz2err = %d", bz2err);
-	BZ2_bzWrite(&bz2err, pfbz2, db, dblen);
-	if (bz2err != BZ_OK)
-		errx(1, "BZ2_bzWrite, bz2err = %d", bz2err);
-	BZ2_bzWriteClose(&bz2err, pfbz2, 0, NULL, NULL);
-	if (bz2err != BZ_OK)
-		errx(1, "BZ2_bzWriteClose, bz2err = %d", bz2err);
-
-	/* Compute size of compressed diff data */
-	if ((newsize = ftello(pf)) == -1)
-		err(1, "ftello");
-	offtout(newsize - len, header + 16);
-
-	/* Write compressed extra data */
-	if ((pfbz2 = BZ2_bzWriteOpen(&bz2err, pf, 9, 0, 0)) == NULL)
-		errx(1, "BZ2_bzWriteOpen, bz2err = %d", bz2err);
-	BZ2_bzWrite(&bz2err, pfbz2, eb, eblen);
-	if (bz2err != BZ_OK)
-		errx(1, "BZ2_bzWrite, bz2err = %d", bz2err);
-	BZ2_bzWriteClose(&bz2err, pfbz2, 0, NULL, NULL);
-	if (bz2err != BZ_OK)
-		errx(1, "BZ2_bzWriteClose, bz2err = %d", bz2err);
-
-	/* Seek to the beginning, write the header, and close the file */
-	if (fseeko(pf, 0, SEEK_SET))
-		err(1, "fseeko");
-	if (fwrite(header, 32, 1, pf) != 1)
-		err(1, "fwrite(%s)", argv[3]);
-	if (fclose(pf))
-		err(1, "fclose");
-
-	/* Free the memory we used */
-	free(db);
-	free(eb);
-	free(I);
-	free(old);
-	free(new);
+  off_t *I,*V;
+  off_t scan,pos,len;
+  off_t lastscan,lastpos,lastoffset;
+  off_t oldscore,scsc;
+  off_t s,Sf,lenf,Sb,lenb;
+  off_t overlap,Ss,lens;
+  off_t i;
+  off_t dblen,eblen;
+  u_char *db,*eb;
+  u_char buf[8];
+  u_char header[32];
+  u_char *fileblock;
+
+  off_t ctrllen;
+
+  /* Sanity checks */
+  if (oldp == NULL || newp == NULL || patch == NULL) return -1;
+  if (oldsize < 0 || newsize < 0 || patchsz < 0)     return -1;
+  if (bsdiff_patchsize_max(oldsize, newsize) > patchsz) return -1;
+
+  /* Allocate oldsize+1 bytes instead of oldsize bytes to ensure
+     that we never try to malloc(0) and get a NULL pointer */
+  if(((I=malloc((oldsize+1)*sizeof(off_t)))==NULL) ||
+     ((V=malloc((oldsize+1)*sizeof(off_t)))==NULL)) return -1;
+
+  qsufsort(I,V,oldp,oldsize);
+
+  free(V);
+
+  /* Allocate newsize+1 bytes instead of newsize bytes to ensure
+     that we never try to malloc(0) and get a NULL pointer */
+  if(((db=malloc(newsize+1))==NULL) ||
+     ((eb=malloc(newsize+1))==NULL)) {
+    free(I);
+    return -1;
+  }
+  dblen=0;
+  eblen=0;
+
+  /* Write initial header */
+  memcpy(header,BSDIFF_CONFIG_MAGIC,8);
+  offtout(0, header + 8);
+  offtout(0, header + 16);
+  offtout(newsize, header + 24);
+  memcpy(patch, header, 32);
+
+  /* Set up initial pointers */
+  fileblock = patch + 32;
+  ctrllen = 0;
+
+  /* Compute the differences, writing ctrl as we go */
+  scan=0;len=0;pos=0;
+  lastscan=0;lastpos=0;lastoffset=0;
+  while(scan<newsize) {
+    oldscore=0;
+
+    for(scsc=scan+=len;scan<newsize;scan++) {
+      len=search(I,oldp,oldsize,newp+scan,newsize-scan,
+                 0,oldsize,&pos);
+
+      for(;scsc<scan+len;scsc++)
+        if((scsc+lastoffset<oldsize) &&
+           (oldp[scsc+lastoffset] == newp[scsc]))
+          oldscore++;
+
+      if(((len==oldscore) && (len!=0)) ||
+         (len>oldscore+8)) break;
+
+      if((scan+lastoffset<oldsize) &&
+         (oldp[scan+lastoffset] == newp[scan]))
+        oldscore--;
+    };
+
+    if((len!=oldscore) || (scan==newsize)) {
+      s=0;Sf=0;lenf=0;
+      for(i=0;(lastscan+i<scan)&&(lastpos+i<oldsize);) {
+        if(oldp[lastpos+i]==newp[lastscan+i]) s++;
+        i++;
+        if(s*2-i>Sf*2-lenf) { Sf=s; lenf=i; };
+      };
+
+      lenb=0;
+      if(scan<newsize) {
+        s=0;Sb=0;
+        for(i=1;(scan>=lastscan+i)&&(pos>=i);i++) {
+          if(oldp[pos-i]==newp[scan-i]) s++;
+          if(s*2-i>Sb*2-lenb) { Sb=s; lenb=i; };
+        };
+      };
+
+      if(lastscan+lenf>scan-lenb) {
+        overlap=(lastscan+lenf)-(scan-lenb);
+        s=0;Ss=0;lens=0;
+        for(i=0;i<overlap;i++) {
+          if(newp[lastscan+lenf-overlap+i]==
+             oldp[lastpos+lenf-overlap+i]) s++;
+          if(newp[scan-lenb+i]==
+             oldp[pos-lenb+i]) s--;
+          if(s>Ss) { Ss=s; lens=i+1; };
+        };
+
+        lenf+=lens-overlap;
+        lenb-=lens;
+      };
+
+      for(i=0;i<lenf;i++)
+        db[dblen+i]=newp[lastscan+i]-oldp[lastpos+i];
+      for(i=0;i<(scan-lenb)-(lastscan+lenf);i++)
+        eb[eblen+i]=newp[lastscan+lenf+i];
+
+      dblen+=lenf;
+      eblen+=(scan-lenb)-(lastscan+lenf);
+
+      offtout(lenf,buf);
+      memcpy(fileblock, buf, 8);
+      fileblock += 8; ctrllen += 8;
+
+      offtout((scan-lenb)-(lastscan+lenf),buf);
+      memcpy(fileblock, buf, 8);
+      fileblock += 8; ctrllen += 8;
+
+      offtout((pos-lenb)-(lastpos+lenf),buf);
+      memcpy(fileblock, buf, 8);
+      fileblock += 8; ctrllen += 8;
+
+      lastscan=scan-lenb;
+      lastpos=pos-lenb;
+      lastoffset=pos-scan;
+    };
+  };
+
+  /* Write size of ctrl data */
+  offtout(ctrllen, header + 8);
+
+  /* Write diff data */
+  memcpy(fileblock, db, dblen);
+  fileblock += dblen;
+  /* Write size of diff data */
+  offtout(dblen, header + 16);
+
+  /* Write extra data */
+  memcpy(fileblock, eb, eblen);
+
+  /* Write the final header */
+  memcpy(patch, header, 32);
+
+  /* Free the memory we used */
+  free(db);
+  free(eb);
+  free(I);
 
-	return 0;
+  return (32+ctrllen+dblen+eblen);
 }
diff -Naur -U 5 bsdiff-4.3/bsdiff.h minibsdiff-master/bsdiff.h
--- bsdiff-4.3/bsdiff.h	1970-01-01 10:00:00.000000000 +1000
+++ minibsdiff-master/bsdiff.h	2014-04-15 13:49:58.000000000 +1000
@@ -0,0 +1,70 @@
+/*-
+ * Copyright 2012-2013 Austin Seipp
+ * Copyright 2003-2005 Colin Percival
+ * All rights reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted providing that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef _MINIBSDIFF_H_
+#define _MINIBSDIFF_H_
+
+#include "minibsdiff-config.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* ------------------------------------------------------------------------- */
+/* -- Public API ----------------------------------------------------------- */
+
+/*-
+ * Determine the maximum size of a patch between two files. This function
+ * should be used to allocate a buffer big enough for `bsdiff` to store
+ * its output in.
+ */
+off_t bsdiff_patchsize_max(off_t oldsize, off_t newsize);
+
+/*-
+ * Create a binary patch from the buffers pointed to by oldp and newp (with
+ * respective sizes,) and store the result in the buffer pointed to by 'patch'.
+ *
+ * The input pointer 'patch' must not be NULL, and the size of the buffer must
+ * be at least 'bsdiff_patchsize_max(new,old)' in length.
+ *
+ * Returns -1 if `patch` is NULL, the 'patch' buffer is not large enough, or if
+ * memory cannot be allocated.
+ * Otherwise, the return value is the size of the patch that was put in the
+ * 'patch' buffer.
+ *
+ * This function is memory-intensive, and requires max(17*n,9*n+m)+O(1) bytes
+ * of memory, where n is the size of the new file and m is the size of the old
+ * file. It runs in O((n+m) log n) time.
+ */
+int bsdiff(u_char* oldp, off_t oldsize,
+           u_char* newp, off_t newsize,
+           u_char* patch, off_t patchsize);
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+
+#endif /* _MINIBSDIFF_H_ */
diff -Naur -U 5 bsdiff-4.3/bspatch.1 minibsdiff-master/bspatch.1
--- bsdiff-4.3/bspatch.1	2005-08-17 08:05:49.000000000 +1000
+++ minibsdiff-master/bspatch.1	1970-01-01 10:00:00.000000000 +1000
@@ -1,59 +0,0 @@
-.\"-
-.\" Copyright 2003-2005 Colin Percival
-.\" All rights reserved
-.\"
-.\" Redistribution and use in source and binary forms, with or without
-.\" modification, are permitted providing that the following conditions
-.\" are met:
-.\" 1. Redistributions of source code must retain the above copyright
-.\"    notice, this list of conditions and the following disclaimer.
-.\" 2. Redistributions in binary form must reproduce the above copyright
-.\"    notice, this list of conditions and the following disclaimer in the
-.\"    documentation and/or other materials provided with the distribution.
-.\"
-.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-.\" WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
-.\" DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
-.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
-.\" STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
-.\" IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-.\" POSSIBILITY OF SUCH DAMAGE.
-.\"
-.\" $FreeBSD: src/usr.bin/bsdiff/bspatch/bspatch.1,v 1.1 2005/08/06 01:59:06 cperciva Exp $
-.\"
-.Dd May 18, 2003
-.Dt BSPATCH 1
-.Os FreeBSD
-.Sh NAME
-.Nm bspatch
-.Nd apply a patch built with bsdiff(1)
-.Sh SYNOPSIS
-.Nm
-.Ao Ar oldfile Ac Ao Ar newfile Ac Ao Ar patchfile Ac
-.Sh DESCRIPTION
-.Nm
-generates
-.Ao Ar newfile Ac
-from
-.Ao Ar oldfile Ac
-and
-.Ao Ar patchfile Ac
-where
-.Ao Ar patchfile Ac
-is a binary patch built by bsdiff(1).
-.Pp
-.Nm
-uses memory equal to the size of 
-.Ao Ar oldfile Ac
-plus the size of 
-.Ao Ar newfile Ac ,
-but can tolerate a very small working set without a dramatic loss
-of performance.
-.Sh SEE ALSO
-.Xr bsdiff 1
-.Sh AUTHORS
-.An Colin Percival Aq cperciva@freebsd.org
diff -Naur -U 5 bsdiff-4.3/bspatch.c minibsdiff-master/bspatch.c
--- bsdiff-4.3/bspatch.c	2005-08-17 08:14:00.000000000 +1000
+++ minibsdiff-master/bspatch.c	2014-04-15 13:49:58.000000000 +1000
@@ -1,11 +1,12 @@
 /*-
+ * Copyright 2012-2013 Austin Seipp
  * Copyright 2003-2005 Colin Percival
  * All rights reserved
  *
  * Redistribution and use in source and binary forms, with or without
- * modification, are permitted providing that the following conditions 
+ * modification, are permitted providing that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer.
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
@@ -26,179 +27,139 @@
 
 #if 0
 __FBSDID("$FreeBSD: src/usr.bin/bsdiff/bspatch/bspatch.c,v 1.1 2005/08/06 01:59:06 cperciva Exp $");
 #endif
 
-#include <bzlib.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
-#include <err.h>
-#include <unistd.h>
-#include <fcntl.h>
+#include <sys/types.h>
 
-static off_t offtin(u_char *buf)
+#include "bspatch.h"
+
+/*
+  Patch file format:
+  0        8       BSDIFF_CONFIG_MAGIC (see minibsdiff-config.h)
+  8        8       X
+  16       8       Y
+  24       8       sizeof(newfile)
+  32       X       control block
+  32+X     Y       diff block
+  32+X+Y   ???     extra block
+  with control block a set of triples (x,y,z) meaning "add x bytes
+  from oldfile to x bytes from the diff block; copy y bytes from the
+  extra block; seek forwards in oldfile by z bytes".
+*/
+
+static off_t
+offtin(u_char *buf)
 {
-	off_t y;
+  off_t y;
 
-	y=buf[7]&0x7F;
-	y=y*256;y+=buf[6];
-	y=y*256;y+=buf[5];
-	y=y*256;y+=buf[4];
-	y=y*256;y+=buf[3];
-	y=y*256;y+=buf[2];
-	y=y*256;y+=buf[1];
-	y=y*256;y+=buf[0];
+  y=buf[7]&0x7F;
+  y=y*256;y+=buf[6];
+  y=y*256;y+=buf[5];
+  y=y*256;y+=buf[4];
+  y=y*256;y+=buf[3];
+  y=y*256;y+=buf[2];
+  y=y*256;y+=buf[1];
+  y=y*256;y+=buf[0];
 
-	if(buf[7]&0x80) y=-y;
+  if(buf[7]&0x80) y=-y;
 
-	return y;
+  return y;
 }
 
-int main(int argc,char * argv[])
+bool
+bspatch_valid_header(u_char* patch, ssize_t patchsz)
 {
-	FILE * f, * cpf, * dpf, * epf;
-	BZFILE * cpfbz2, * dpfbz2, * epfbz2;
-	int cbz2err, dbz2err, ebz2err;
-	int fd;
-	ssize_t oldsize,newsize;
-	ssize_t bzctrllen,bzdatalen;
-	u_char header[32],buf[8];
-	u_char *old, *new;
-	off_t oldpos,newpos;
-	off_t ctrl[3];
-	off_t lenread;
-	off_t i;
-
-	if(argc!=4) errx(1,"usage: %s oldfile newfile patchfile\n",argv[0]);
-
-	/* Open patch file */
-	if ((f = fopen(argv[3], "r")) == NULL)
-		err(1, "fopen(%s)", argv[3]);
-
-	/*
-	File format:
-		0	8	"BSDIFF40"
-		8	8	X
-		16	8	Y
-		24	8	sizeof(newfile)
-		32	X	bzip2(control block)
-		32+X	Y	bzip2(diff block)
-		32+X+Y	???	bzip2(extra block)
-	with control block a set of triples (x,y,z) meaning "add x bytes
-	from oldfile to x bytes from the diff block; copy y bytes from the
-	extra block; seek forwards in oldfile by z bytes".
-	*/
-
-	/* Read header */
-	if (fread(header, 1, 32, f) < 32) {
-		if (feof(f))
-			errx(1, "Corrupt patch\n");
-		err(1, "fread(%s)", argv[3]);
-	}
-
-	/* Check for appropriate magic */
-	if (memcmp(header, "BSDIFF40", 8) != 0)
-		errx(1, "Corrupt patch\n");
-
-	/* Read lengths from header */
-	bzctrllen=offtin(header+8);
-	bzdatalen=offtin(header+16);
-	newsize=offtin(header+24);
-	if((bzctrllen<0) || (bzdatalen<0) || (newsize<0))
-		errx(1,"Corrupt patch\n");
-
-	/* Close patch file and re-open it via libbzip2 at the right places */
-	if (fclose(f))
-		err(1, "fclose(%s)", argv[3]);
-	if ((cpf = fopen(argv[3], "r")) == NULL)
-		err(1, "fopen(%s)", argv[3]);
-	if (fseeko(cpf, 32, SEEK_SET))
-		err(1, "fseeko(%s, %lld)", argv[3],
-		    (long long)32);
-	if ((cpfbz2 = BZ2_bzReadOpen(&cbz2err, cpf, 0, 0, NULL, 0)) == NULL)
-		errx(1, "BZ2_bzReadOpen, bz2err = %d", cbz2err);
-	if ((dpf = fopen(argv[3], "r")) == NULL)
-		err(1, "fopen(%s)", argv[3]);
-	if (fseeko(dpf, 32 + bzctrllen, SEEK_SET))
-		err(1, "fseeko(%s, %lld)", argv[3],
-		    (long long)(32 + bzctrllen));
-	if ((dpfbz2 = BZ2_bzReadOpen(&dbz2err, dpf, 0, 0, NULL, 0)) == NULL)
-		errx(1, "BZ2_bzReadOpen, bz2err = %d", dbz2err);
-	if ((epf = fopen(argv[3], "r")) == NULL)
-		err(1, "fopen(%s)", argv[3]);
-	if (fseeko(epf, 32 + bzctrllen + bzdatalen, SEEK_SET))
-		err(1, "fseeko(%s, %lld)", argv[3],
-		    (long long)(32 + bzctrllen + bzdatalen));
-	if ((epfbz2 = BZ2_bzReadOpen(&ebz2err, epf, 0, 0, NULL, 0)) == NULL)
-		errx(1, "BZ2_bzReadOpen, bz2err = %d", ebz2err);
-
-	if(((fd=open(argv[1],O_RDONLY,0))<0) ||
-		((oldsize=lseek(fd,0,SEEK_END))==-1) ||
-		((old=malloc(oldsize+1))==NULL) ||
-		(lseek(fd,0,SEEK_SET)!=0) ||
-		(read(fd,old,oldsize)!=oldsize) ||
-		(close(fd)==-1)) err(1,"%s",argv[1]);
-	if((new=malloc(newsize+1))==NULL) err(1,NULL);
-
-	oldpos=0;newpos=0;
-	while(newpos<newsize) {
-		/* Read control data */
-		for(i=0;i<=2;i++) {
-			lenread = BZ2_bzRead(&cbz2err, cpfbz2, buf, 8);
-			if ((lenread < 8) || ((cbz2err != BZ_OK) &&
-			    (cbz2err != BZ_STREAM_END)))
-				errx(1, "Corrupt patch\n");
-			ctrl[i]=offtin(buf);
-		};
-
-		/* Sanity-check */
-		if(newpos+ctrl[0]>newsize)
-			errx(1,"Corrupt patch\n");
-
-		/* Read diff string */
-		lenread = BZ2_bzRead(&dbz2err, dpfbz2, new + newpos, ctrl[0]);
-		if ((lenread < ctrl[0]) ||
-		    ((dbz2err != BZ_OK) && (dbz2err != BZ_STREAM_END)))
-			errx(1, "Corrupt patch\n");
-
-		/* Add old data to diff string */
-		for(i=0;i<ctrl[0];i++)
-			if((oldpos+i>=0) && (oldpos+i<oldsize))
-				new[newpos+i]+=old[oldpos+i];
-
-		/* Adjust pointers */
-		newpos+=ctrl[0];
-		oldpos+=ctrl[0];
-
-		/* Sanity-check */
-		if(newpos+ctrl[1]>newsize)
-			errx(1,"Corrupt patch\n");
-
-		/* Read extra string */
-		lenread = BZ2_bzRead(&ebz2err, epfbz2, new + newpos, ctrl[1]);
-		if ((lenread < ctrl[1]) ||
-		    ((ebz2err != BZ_OK) && (ebz2err != BZ_STREAM_END)))
-			errx(1, "Corrupt patch\n");
-
-		/* Adjust pointers */
-		newpos+=ctrl[1];
-		oldpos+=ctrl[2];
-	};
-
-	/* Clean up the bzip2 reads */
-	BZ2_bzReadClose(&cbz2err, cpfbz2);
-	BZ2_bzReadClose(&dbz2err, dpfbz2);
-	BZ2_bzReadClose(&ebz2err, epfbz2);
-	if (fclose(cpf) || fclose(dpf) || fclose(epf))
-		err(1, "fclose(%s)", argv[3]);
-
-	/* Write the new file */
-	if(((fd=open(argv[2],O_CREAT|O_TRUNC|O_WRONLY,0666))<0) ||
-		(write(fd,new,newsize)!=newsize) || (close(fd)==-1))
-		err(1,"%s",argv[2]);
+  ssize_t newsize, ctrllen, datalen;
+
+  if (patchsz < 32) return false;
 
-	free(new);
-	free(old);
+  /* Make sure magic and header fields are valid */
+  if(memcmp(patch, BSDIFF_CONFIG_MAGIC, 8) != 0) return false;
+
+  ctrllen=offtin(patch+8);
+  datalen=offtin(patch+16);
+  newsize=offtin(patch+24);
+  if((ctrllen<0) || (datalen<0) || (newsize<0))
+    return false;
+
+  return true;
+}
+
+ssize_t
+bspatch_newsize(u_char* patch, ssize_t patchsz)
+{
+  if (!bspatch_valid_header(patch, patchsz)) return -1;
+  return offtin(patch+24);
+}
+
+int
+bspatch(u_char* oldp,  ssize_t oldsz,
+        u_char* patch, ssize_t patchsz,
+        u_char* newp,  ssize_t newsz)
+{
+  ssize_t newsize,ctrllen,datalen;
+  u_char *ctrlblock, *diffblock, *extrablock;
+  off_t oldpos,newpos;
+  off_t ctrl[3];
+  off_t i;
+
+  /* Sanity checks */
+  if (oldp == NULL || patch == NULL || newp == NULL) return -1;
+  if (oldsz < 0    || patchsz < 0   || newsz < 0)    return -1;
+  if (!bspatch_valid_header(patch, patchsz)) return -2;
+
+  /* Read lengths from patch header */
+  ctrllen=offtin(patch+8);
+  datalen=offtin(patch+16);
+  newsize=offtin(patch+24);
+  if (newsize > newsz) return -1;
+
+  /* Get pointers into the header metadata */
+  ctrlblock  = patch+32;
+  diffblock  = patch+32+ctrllen;
+  extrablock = patch+32+ctrllen+datalen;
+
+  /* Apply patch */
+  oldpos=0;newpos=0;
+  while(newpos<newsize) {
+    /* Read control block */
+    ctrl[0] = offtin(ctrlblock);
+    ctrl[1] = offtin(ctrlblock+8);
+    ctrl[2] = offtin(ctrlblock+16);
+    ctrlblock += 24;
+
+    /* Sanity check */
+    if(newpos+ctrl[0]>newsize)
+      return -3; /* Corrupt patch */
+
+    /* Read diff string */
+    memcpy(newp + newpos, diffblock, ctrl[0]);
+    diffblock += ctrl[0];
+
+    /* Add old data to diff string */
+    for(i=0;i<ctrl[0];i++)
+      if((oldpos+i>=0) && (oldpos+i<oldsz))
+        newp[newpos+i]+=oldp[oldpos+i];
+
+    /* Adjust pointers */
+    newpos+=ctrl[0];
+    oldpos+=ctrl[0];
+
+    /* Sanity check */
+    if(newpos+ctrl[1]>newsize)
+      return -3; /* Corrupt patch */
+
+    /* Read extra string */
+    memcpy(newp + newpos, extrablock, ctrl[1]);
+    extrablock += ctrl[1];
+
+    /* Adjust pointers */
+    newpos+=ctrl[1];
+    oldpos+=ctrl[2];
+  };
 
-	return 0;
+  return 0;
 }
diff -Naur -U 5 bsdiff-4.3/bspatch.h minibsdiff-master/bspatch.h
--- bsdiff-4.3/bspatch.h	1970-01-01 10:00:00.000000000 +1000
+++ minibsdiff-master/bspatch.h	2014-04-15 13:49:58.000000000 +1000
@@ -0,0 +1,78 @@
+/*-
+ * Copyright 2012-2013 Austin Seipp
+ * Copyright 2003-2005 Colin Percival
+ * All rights reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted providing that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef _MINIBSPATCH_H_
+#define _MINIBSPATCH_H_
+
+#include "minibsdiff-config.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* ------------------------------------------------------------------------- */
+/* -- Public API ----------------------------------------------------------- */
+
+/*-
+ * Determine if the buffer pointed to by `patch` of a given `size` is
+ * a valid patch.
+ */
+bool bspatch_valid_header(u_char* patch, ssize_t patchsz);
+
+/*-
+ * Determine the size of the new file that will result from applying
+ * a patch. Returns -1 if the patch header is invalid, otherwise returns
+ * the size of the new file.
+ */
+ssize_t bspatch_newsize(u_char* patch, ssize_t patchsize);
+
+/*-
+ * Apply a patch stored in 'patch' to 'oldp', result in 'newp', and store the
+ * result in 'newp'.
+ *
+ * The input pointers must not be NULL.
+ *
+ * The size of 'newp', represented by 'newsz', must be at least
+ * 'bspatch_newsize(oldsz,patchsz)' bytes in length.
+ *
+ * Returns -1 if memory can't be allocated, or the input pointers are NULL.
+ * Returns -2 if the patch header is invalid. Returns -3 if the patch itself is
+ * corrupt.
+ * Otherwise, returns 0.
+ *
+ * This function requires n+m+O(1) bytes of memory, where n is the size of the
+ * old file and m is the size of the new file. It does no allocations.
+ * It runs in O(n+m) time.
+ */
+int bspatch(u_char* oldp,  ssize_t oldsz,
+            u_char* patch, ssize_t patchsz,
+            u_char* newp,  ssize_t newsz);
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+
+#endif /* _MINIBSPATCH_H_ */
diff -Naur -U 5 bsdiff-4.3/.gitignore minibsdiff-master/.gitignore
--- bsdiff-4.3/.gitignore	1970-01-01 10:00:00.000000000 +1000
+++ minibsdiff-master/.gitignore	2014-04-15 13:49:58.000000000 +1000
@@ -0,0 +1,9 @@
+.DS_Store
+*~
+*.o
+minibsdiff
+*.exe
+*.swp
+
+build*/
+/result
diff -Naur -U 5 bsdiff-4.3/LICENSE.txt minibsdiff-master/LICENSE.txt
--- bsdiff-4.3/LICENSE.txt	1970-01-01 10:00:00.000000000 +1000
+++ minibsdiff-master/LICENSE.txt	2014-04-15 13:49:58.000000000 +1000
@@ -0,0 +1,60 @@
+===============================================================================
+[ minibsdiff contains code from bsdiff; both are under 2-Clause BSD license: ]
+
+Copyright (c) 2012-2013 Austin Seipp <mad.one@gmail.com>
+Copyright (c) 2003-2005 Colin Percival
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted providing that the following conditions
+are met:
+
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the
+   distribution.
+
+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+===============================================================================
+[ minibsdiff contains code from the msinttypes project, with this license: ]
+
+Copyright (c) 2006-2008 Alexander Chemeris
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+  1. Redistributions of source code must retain the above copyright notice,
+     this list of conditions and the following disclaimer.
+
+  2. Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+
+  3. The name of the author may be used to endorse or promote products
+     derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
+EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
+WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff -Naur -U 5 bsdiff-4.3/Makefile minibsdiff-master/Makefile
--- bsdiff-4.3/Makefile	2005-08-17 08:14:10.000000000 +1000
+++ minibsdiff-master/Makefile	2014-04-15 13:49:58.000000000 +1000
@@ -1,15 +1,133 @@
-CFLAGS		+=	-O3 -lbz2
+# -- Configuration -------------------------------------------------------------
 
-PREFIX		?=	/usr/local
-INSTALL_PROGRAM	?=	${INSTALL} -c -s -m 555
-INSTALL_MAN	?=	${INSTALL} -c -m 444
-
-all:		bsdiff bspatch
-bsdiff:		bsdiff.c
-bspatch:	bspatch.c
-
-install:
-	${INSTALL_PROGRAM} bsdiff bspatch ${PREFIX}/bin
-.ifndef WITHOUT_MAN
-	${INSTALL_MAN} bsdiff.1 bspatch.1 ${PREFIX}/man/man1
-.endif
+CC?=cc
+OPTIMIZATION?=-O3 -march=native -fomit-frame-pointer -funroll-loops
+
+STD  = -std=c99 -pedantic
+WARN = -Wall -Wextra
+OPT  = $(OPTIMIZATION)
+
+PREFIX?=/usr/local
+DPREFIX=$(DESTDIR)$(PREFIX)
+INSTALL_BIN=$(DPREFIX)/bin
+INSTALL_LIB=$(DPREFIX)/lib
+INSTALL_INCLUDE=$(DPREFIX)/include
+INSTALL=install
+
+# -- Setup ---------------------------------------------------------------------
+
+USING_COMPCERT=$(shell sh -c '(($(CC) --help | grep CompCert) > /dev/null && echo YES) || echo NO')
+
+ifdef DEBUG
+DEBUGOPT=-g -gdb
+
+ifdef ASAN
+DEBUGOPT+=-fsanitize=address
+endif
+ifdef UBSAN
+DEBUGOPT+=-fsanitize=undefined
+endif
+endif
+
+ifeq ($(USING_COMPCERT),YES)
+# CompCert has pretty non-standard flags
+MY_CFLAGS=$(DEBUGOPT)
+else
+MY_CFLAGS=$(STD) $(WARN) $(OPT) $(DEBUGOPT) $(CFLAGS)
+endif
+
+CCCOLOR="\033[34m"
+LINKCOLOR="\033[34;1m"
+SRCCOLOR="\033[33m"
+BINCOLOR="\033[37;1m"
+MAKECOLOR="\033[32;1m"
+ENDCOLOR="\033[0m"
+
+ifndef V
+QUIET_CC = @printf '    %b         %b\n' $(CCCOLOR)CC$(ENDCOLOR) $(SRCCOLOR)$@$(ENDCOLOR) 1>&2;
+QUIET_AR = @printf '    %b         %b\n' $(CCCOLOR)AR$(ENDCOLOR) $(SRCCOLOR)$@$(ENDCOLOR) 1>&2;
+QUIET_LINK = @printf '    %b       %b\n' $(LINKCOLOR)LINK$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR) 1>&2;
+QUIET_RANLIB = @printf '    %b     %b\n' $(LINKCOLOR)RANLIB$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR) 1>&2;
+QUIET_INSTALL = @printf '    %b    %b\n' $(LINKCOLOR)INSTALL$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR) 1>&2;
+QUIET_CLANG = @printf '    %b      %b\n' $(CCCOLOR)CLANG$(ENDCOLOR) $(SRCCOLOR)$@$(ENDCOLOR) 1>&2;
+QUIET_LSS = @printf '    %b        %b\n' $(LINKCOLOR)LSS$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR) 1>&2;
+QUIET_FRAMAC = @printf '    %b    %b\n' $(LINKCOLOR)FRAMA-C$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR) 1>&2;
+QUIET_CRYPTOL_PROVE = @printf '    %b %b\n' $(LINKCOLOR)CRYPTOL[P]$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR) 1>&2;
+QUIET_CRYPTOL_CHECK = @printf '    %b %b\n' $(LINKCOLOR)CRYPTOL[C]$(ENDCOLOR) $(BINCOLOR)$<$(ENDCOLOR) 1>&2;
+QUIET_CRYPTOL_GENTEST = @printf '    %b %b\n' $(LINKCOLOR)CRYPTOL[G]$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR) 1>&2;
+endif
+
+QCC=$(QUIET_CC) $(CC)
+QAR=$(QUIET_AR) ar
+QLINK=$(QUIET_LINK) $(CC)
+QRANLIB=$(QUIET_RANLIB) ranlib
+QINSTALL=$(QUIET_INSTALL) $(INSTALL)
+
+E=@echo
+ifndef V
+Q=@
+else
+Q=
+endif
+
+# -- Rules ---------------------------------------------------------------------
+
+all:  minibsdiff libminibsdiff.a libminibsdiff.so
+
+DATE=`date +"%Y%m%d"`
+RELNAME=minibsdiff-`git describe`
+tag:
+	$(Q)git tag -a -m 'Version $(DATE)' $(DATE)
+tarball:
+	$(Q)git archive --prefix=$(RELNAME)/ -o $(RELNAME).tar.xz HEAD
+
+clean:
+	$(Q)rm -f *.xz *.a *.so *.o *.dyn_o *~ minibsdiff
+
+# -- Build rules ---------------------------------------------------------------
+
+minibsdiff: minibsdiff.c
+	$(QCC) $(MY_CFLAGS) -o $@ $<
+
+libminibsdiff.so: bsdiff.dyn_o bspatch.dyn_o
+	$(QLINK) -shared -o $@ bsdiff.dyn_o bspatch.dyn_o
+libminibsdiff.a: bsdiff.o bspatch.o
+	$(QAR) -rc $@ bsdiff.o bspatch.o
+	$(QRANLIB) $@
+
+%.o: %.c
+	$(QCC) $(MY_CFLAGS) -o $@ -c $<
+%.dyn_o: %.c
+	$(QCC) $(MY_CFLAGS) -fPIC -o $@ -c $<
+
+# -- Install rules -------------------------------------------------------------
+
+install: 	$(INSTALL_LIB)/libminibsdiff.a \
+	 	$(INSTALL_LIB)/libminibsdiff.so \
+		$(INSTALL_INCLUDE)/bsdiff.h $(INSTALL_INCLUDE)/bspatch.h \
+		$(INSTALL_BIN)/minibsdiff
+
+$(INSTALL_INCLUDE)/bsdiff.h: bsdiff.h
+	$(Q)mkdir -p $(INSTALL_INCLUDE)
+	$(QINSTALL) $< $(INSTALL_INCLUDE)
+
+$(INSTALL_INCLUDE)/bspatch.h: bspatch.h
+	$(Q)mkdir -p $(INSTALL_INCLUDE)
+	$(QINSTALL) $< $(INSTALL_INCLUDE)
+
+$(INSTALL_LIB)/libminibsdiff.a: libminibsdiff.a
+	$(Q)mkdir -p $(INSTALL_LIB)
+	$(QINSTALL) $< $(INSTALL_LIB)
+
+$(INSTALL_LIB)/libminibsdiff.so: libminibsdiff.so
+	$(Q)mkdir -p $(INSTALL_LIB)
+	$(QINSTALL) $< $(INSTALL_LIB)
+
+$(INSTALL_BIN)/minibsdiff: minibsdiff
+	$(Q)mkdir -p $(INSTALL_BIN)
+	$(QINSTALL) $< $(INSTALL_BIN)
+
+uninstall:
+	$(Q)rm -f $(INSTALL_LIB)/libminibsdiff.a
+	$(Q)rm -f $(INSTALL_LIB)/libminibsdiff.so
+	$(Q)rm -f $(INSTALL_INCLUDE)/bsdiff.h $(INSTALL_INCLUDE)/bspatch.h
diff -Naur -U 5 bsdiff-4.3/minibsdiff.c minibsdiff-master/minibsdiff.c
--- bsdiff-4.3/minibsdiff.c	1970-01-01 10:00:00.000000000 +1000
+++ minibsdiff-master/minibsdiff.c	2014-04-15 13:49:58.000000000 +1000
@@ -0,0 +1,223 @@
+/*-
+ * Copyright 2012-2013 Austin Seipp
+ * Copyright 2003-2005 Colin Percival
+ * All rights reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted providing that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*-
+ * This is just a simple example of using
+ * the portable bsdiff API. Parts of it are derived
+ * from the original bsdiff/bspatch.
+ *
+ * Compile with:
+ *
+ *   $ cc -Wall -std=c99 -O2 minibsdiff.c bsdiff.c bspatch.c
+ *
+ * Usage:
+ *
+ *   $ ./a.out gen <v1> <v2> <patch>
+ *   $ ./a.out app <v1> <patch> <v2>
+ */
+
+#ifdef _MSC_VER
+#define _CRT_SECURE_NO_WARNINGS 1
+#endif /* _MSC_VER */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/types.h>
+
+/* Create one large compilation unit */
+#include "bspatch.c"
+#include "bsdiff.c"
+
+/* ------------------------------------------------------------------------- */
+/* -- Utilities ------------------------------------------------------------ */
+
+static char* progname;
+
+static void
+barf(const char* msg)
+{
+  printf("%s: ERROR: %s", progname, msg);
+  exit(EXIT_FAILURE);
+}
+
+static void
+usage(void)
+{
+  printf("usage:\n\n"
+         "Generate patch:"
+         "\t$ %s gen <v1> <v2> <patch>\n"
+         "Apply patch:"
+         "\t$ %s app <v1> <patch> <v2>\n", progname, progname);
+  exit(EXIT_FAILURE);
+}
+
+static long
+read_file(const char* f, u_char** buf)
+{
+  FILE* fp;
+  long fsz;
+
+  fsz = 0;
+  if ( ((fp = fopen(f, "rb"))  == NULL)         ||
+       (fseek(fp, 0, SEEK_END)  != 0)           ||
+       ((fsz = ftell(fp))       == -1)          ||
+       ((*buf = malloc(fsz+1))  == NULL)        ||
+       (fseek(fp, 0, SEEK_SET)  != 0)           ||
+       (fread(*buf, 1, fsz, fp) != (size_t)fsz) ||
+       (fclose(fp)              != 0)
+     ) barf("Couldn't open file for reading!\n");
+
+  return fsz;
+}
+
+static void
+write_file(const char* f, u_char* buf, long sz)
+{
+  FILE* fp;
+
+  if ( ((fp = fopen(f, "w+b")) == NULL)       ||
+       (fwrite(buf, 1, sz, fp) != (size_t)sz) ||
+       (fclose(fp)             != 0)
+     ) barf("Couldn't open file for writing!\n");
+
+  return;
+}
+
+/* ------------------------------------------------------------------------- */
+/* -- Main routines -------------------------------------------------------- */
+
+static void
+diff(const char* oldf, const char* newf, const char* patchf)
+{
+  u_char* old;
+  u_char* new;
+  u_char* patch;
+  long oldsz, newsz;
+  off_t patchsz;
+  int res;
+
+#ifndef NDEBUG
+  printf("Generating binary patch between %s and %s\n", oldf, newf);
+#endif /* NDEBUG */
+
+  /* Read old and new files */
+  oldsz = read_file(oldf, &old);
+  newsz = read_file(newf, &new);
+
+#ifndef NDEBUG
+  printf("Old file = %lu bytes\nNew file = %lu bytes\n", oldsz, newsz);
+#endif /* NDEBUG */
+
+  /* Compute delta */
+#ifndef NDEBUG
+  printf("Computing binary delta...\n");
+#endif /* NDEBUG */
+
+  patchsz = bsdiff_patchsize_max(oldsz, newsz);
+  patch = malloc(patchsz+1); /* Never malloc(0) */
+  res = bsdiff(old, oldsz, new, newsz, patch, patchsz);
+  if (res <= 0) barf("bsdiff() failed!");
+  patchsz = res;
+
+#ifndef NDEBUG
+  printf("sizeof(delta('%s', '%s')) = %ld bytes\n", oldf, newf, patchsz);
+#endif /* NDEBUG */
+
+  /* Write patch */
+  write_file(patchf, patch, patchsz);
+
+  free(old);
+  free(new);
+  free(patch);
+
+#ifndef NDEBUG
+  printf("Created patch file %s\n", patchf);
+#endif /* NDEBUG */
+  exit(EXIT_SUCCESS);
+}
+
+static void
+patch(const char* inf, const char* patchf, const char* outf)
+{
+  u_char* inp;
+  u_char* patchp;
+  u_char* newp;
+  long insz, patchsz;
+  ssize_t newsz;
+  int res;
+
+#ifndef NDEBUG
+  printf("Applying binary patch %s to %s\n", patchf, inf);
+#endif /* NDEBUG */
+
+  /* Read old file and patch file */
+  insz    = read_file(inf, &inp);
+  patchsz = read_file(patchf, &patchp);
+#ifndef NDEBUG
+  printf("Old file = %lu bytes\nPatch file = %lu bytes\n", insz, patchsz);
+#endif /* NDEBUG */
+
+  /* Apply delta */
+  newsz = bspatch_newsize(patchp, patchsz);
+  if (newsz <= 0) barf("Couldn't determine new file size; patch corrupt!");
+
+  newp = malloc(newsz+1); /* Never malloc(0) */
+  res = bspatch(inp, insz, patchp, patchsz, newp, newsz);
+  if (res != 0) barf("bspatch() failed!");
+
+  /* Write new file */
+  write_file(outf, newp, newsz);
+
+  free(inp);
+  free(patchp);
+  free(newp);
+
+#ifndef NDEBUG
+  printf("Successfully applied patch; new file is %s\n", outf);
+#endif /* NDEBUG */
+  exit(EXIT_SUCCESS);
+}
+
+/* ------------------------------------------------------------------------- */
+/* -- Driver --------------------------------------------------------------- */
+
+int
+main(int ac, char* av[])
+{
+  /* WIN32 FIXME: av[0] becomes the full path to minibsdiff */
+  progname = av[0];
+  if (ac != 5) usage();
+
+  if (memcmp(av[1], "gen", 3) == 0)
+    diff(av[2], av[3], av[4]);
+  if (memcmp(av[1], "app", 3) == 0)
+    patch(av[2], av[3], av[4]);
+
+  usage(); /* patch()/diff() don't return */
+  return 0;
+}
diff -Naur -U 5 bsdiff-4.3/minibsdiff-config.h minibsdiff-master/minibsdiff-config.h
--- bsdiff-4.3/minibsdiff-config.h	1970-01-01 10:00:00.000000000 +1000
+++ minibsdiff-master/minibsdiff-config.h	2014-04-15 13:49:58.000000000 +1000
@@ -0,0 +1,64 @@
+/*-
+ * Copyright 2012-2013 Austin Seipp
+ * Copyright 2003-2005 Colin Percival
+ * All rights reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted providing that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef _MINIBSDIFF_CONFIG_H_
+#define _MINIBSDIFF_CONFIG_H_
+
+#ifdef _MSC_VER
+#include <Windows.h>
+#include "stdint-msvc.h"
+#include "stdbool-msvc.h"
+#else
+#include <stdint.h>
+#include <stdbool.h>
+#endif /* _MSC_VER */
+
+/* ------------------------------------------------------------------------- */
+/* -- Patch file magic number ---------------------------------------------- */
+
+/** MUST be 8 bytes long! */
+/** TODO FIXME: we should static_assert this */
+#define BSDIFF_CONFIG_MAGIC "MBSDIF43"
+
+/* ------------------------------------------------------------------------- */
+/* -- Slop size for temporary patch buffer --------------------------------- */
+
+#define BSDIFF_PATCH_SLOP_SIZE 102400
+
+/* ------------------------------------------------------------------------- */
+/* -- Type definitions ----------------------------------------------------- */
+
+/* Duplicated to keep code small. Keep in sync with bspatch.h! */
+#ifndef _MINIBSDIFF_U_CHAR_T_
+#define _MINIBSDIFF_U_CHAR_T_
+typedef uint8_t u_char;
+#endif /* _MINIBSDIFF_U_CHAR_T_ */
+
+#ifdef _MSC_VER
+typedef SSIZE_T ssize_t;
+#endif /* _MSC_VER */
+
+#endif /* _MINIBSDIFF_CONFIG_H_ */
diff -Naur -U 5 bsdiff-4.3/README.md minibsdiff-master/README.md
--- bsdiff-4.3/README.md	1970-01-01 10:00:00.000000000 +1000
+++ minibsdiff-master/README.md	2014-04-15 13:49:58.000000000 +1000
@@ -0,0 +1,219 @@
+# minibsdiff: a miniature, portable version of bsdiff [![Build Status][]](http://travis-ci.org/thoughtpolice/minibsdiff)
+
+[Build Status]: https://secure.travis-ci.org/thoughtpolice/minibsdiff.png?branch=master
+
+Colin Percival's [bsdiff][] is a popular tool for creating and applying patches
+to binary software. This is a stripped down copy of `bsdiff` that's designed to
+be portable and reusable as a library in your own software (if you wanted to
+say, create your own update system.) Many people end up reusing bsdiff (it's
+stable, well-known, works great, and has a good license,) but I haven't found a
+standalone copy of the library somewhere that I could easily reuse, so I made it.
+
+This code is based on [bsdiff v4.3](http://www.daemonology.net/bsdiff/bsdiff-4.3.tar.gz).
+
+The main differences:
+
+  * Control and data blocks in the patch output are not `bzip2` compressed.
+    You'll have to apply your own compression method. **This is a very
+    important part of bsdiff's design, and if you don't apply a compression
+    method at some level when using this library, it won't buy you anything**.
+    Please see the 'Usage' section below.
+
+  * Patches produced by this library are incompatible with those produced by
+    the classic bsdiff tool. (The header format has changed appropriately so
+    they are both incompatible with each other.) You're encouraged to change
+    this when using the library yourself - see 'Usage' below.
+
+  * The code has been refactored into a reusable API (documented below)
+    consisting of a few simple functions in `bsdiff.h` and `bspatch.h`. It
+    should be easily usable from any programming language. It has zero external
+    dependencies.
+
+  * It works everywhere (even under MSVC.)
+
+  * There's a simple example included that should show you how to get started.
+
+  * Because there are no external dependencies and it's so small, **minibsdiff
+    is great place to start if you need to customize bsdiff yourself**! You'll
+    inevitably want to do this as time goes on, and most of the work is done
+    for you.
+
+# Usage
+
+## Building
+
+Copy `bsdiff.{c,h}`, `bspatch.{c,h}`, `minibsdiff-config.h` and
+`{stdbool,stdint}-msvc.h` in your source tree and you're ready to go. You
+shouldn't need any special build settings for it to Just Work(TM).
+
+## API
+
+```c
+#include "bsdiff.h"
+#include "bspatch.h"
+
+/*-
+ * Determine the maximum size of a patch between two files. This function
+ * should be used to allocate a buffer big enough for `bsdiff` to store
+ * its output in.
+ */
+off_t bsdiff_patchsize_max(off_t oldsize, off_t newsize);
+
+/*-
+ * Create a binary patch from the buffers pointed to by oldp and newp (with
+ * respective sizes,) and store the result in the buffer pointed to by 'patch'.
+ *
+ * The input pointer 'patch' must not be NULL, and the size of the buffer must
+ * be at least 'bsdiff_patchsize_max(new,old)' in length.
+ *
+ * Returns -1 if `patch` is NULL, the 'patch' buffer is not large enough, or if
+ * memory cannot be allocated.
+ * Otherwise, the return value is the size of the patch that was put in the
+ * 'patch' buffer.
+ *
+ * This function is memory-intensive, and requires max(17*n,9*n+m)+O(1) bytes
+ * of memory, where n is the size of the new file and m is the size of the old
+ * file. It runs in O((n+m) log n) time.
+ */
+int bsdiff(u_char* oldp, off_t oldsize,
+           u_char* newp, off_t newsize,
+           u_char* patch, off_t patchsize);
+
+/*-
+ * Determine if the buffer pointed to by `patch` of a given `size` is
+ * a valid patch.
+ */
+bool bspatch_valid_header(u_char* patch, ssize_t patchsz);
+
+/*-
+ * Determine the size of the new file that will result from applying
+ * a patch. Returns -1 if the patch header is invalid, otherwise returns
+ * the size of the new file.
+ */
+ssize_t bspatch_newsize(u_char* patch, ssize_t patchsize);
+
+/*-
+ * Apply a patch stored in 'patch' to 'oldp', result in 'newp', and store the
+ * result in 'newp'.
+ *
+ * The input pointers must not be NULL.
+ *
+ * The size of 'newp', represented by 'newsz', must be at least
+ * 'bspatch_newsize(oldsz,patchsz)' bytes in length.
+ *
+ * Returns -1 if memory can't be allocated, or the input pointers are NULL.
+ * Returns -2 if the patch header is invalid. Returns -3 if the patch itself is
+ * corrupt.
+ * Otherwise, returns 0.
+ *
+ * This function requires n+m+O(1) bytes of memory, where n is the size of the
+ * old file and m is the size of the new file. It does no allocations.
+ * It runs in O(n+m) time.
+ */
+int bspatch(u_char* oldp,  ssize_t oldsz,
+            u_char* patch, ssize_t patchsz,
+            u_char* newp,  ssize_t newsz);
+
+```
+
+## Building the example program.
+
+For an full example of using the API, see `minibsdiff.c`, which roughly
+reimplements the standard `bsdiff/bspatch` in a single tool (without
+compression.) To build it:
+
+  * Running `make` on Linux or OS X. If you have MinGW installed and on
+    your `PATH` then you can do `make MinGW=YES` which will build an
+    `.exe` on Windows.
+
+  * There is a `CMakeLists.txt` file you can use to generate Ninja, MSVC or
+    MinGW makefile projects for Windows as well. You can of course use `cmake`
+    on Linux/OS X as well.
+
+## Customization notes.
+
+You can change the patch file's magic number by modifying `BSDIFF_CONFIG_MAGIC`
+in `minibsdiff-config.h`. It must be 8 bytes long (anything beyond that will be
+ignored.) This library by default has the magic number `MBSDIF43`.
+
+---
+
+**You should really, really, really compress the output in some way**. Whether
+or not you do that directly in the diff/patch routines or on the result you get
+from calling them is irrelevant. If you don't do this, **bsdiff will buy you
+nothing**.
+
+Briefly, bsdiff is based on the concept of finding approximate matches between
+two executable files, and calculating and storing their bytewise differences in
+the patch file. The patch format is roughly composed of a control block
+specifying how to add and insert changes from the new executable into the old
+one, and a difference block actually composed of the differences.
+
+Binary updates to software packages tend to have disproportionate amounts of
+binary-level differences from just a few source code changes. The key
+observation however is that most code is still the same, but *relocated* in
+such a way that things like internal pointers are always offset in a
+predictable manner.  For example, if you have a single translation unit with 5
+functions, and you fix a small bug in this code and ship it to users, the
+*symbolic representation* has not changed all that much, but the change will
+result in *executable* differences affecting all 5 functions, such that e.g.
+relative pointers must all be adjusted properly, across all of them.
+
+But even then, many of these 'relocations' will be small (a byte or two,) and
+more than that, they will often be very regular, meaning the differences are
+highly redundant, and thus compressible.
+
+As a result, an uncompressed patch from bsdiff is roughly on par with the new
+file in size, but compression can reduce it's size dramatically due to repeated
+data in the differences (by a factor of 10x or 20x.) In fact, without some sort
+of compression, it practically defeats the purpose of using it in the first
+place!
+
+Not having compression by default is still a feature, though - it keeps the
+library simple and portable, and you can layer it in however you want because
+the source is small and easy to hack. But realistically, you'll **always** want
+to compress it at one point or another in the Real World.
+
+Here are some good compression libraries you might be interested in:
+
+  * [zlib](http://www.zlib.net)
+  * [gzip](http://www.gzip.org)
+  * [lz4](http://code.google.com/p/lz4)
+  * [snappy](http://code.google.com/p/snappy)
+  * [quicklz](http://www.quicklz.com)
+
+In my non-scientific experiments, **bzip at compression level 9 gives the best
+output size** out of all the ones listed above. It's obviously worth
+sacrificing compression time/speed for smaller updates that decompress quickly.
+
+# Join in
+
+File bugs in the GitHub [issue tracker][].
+
+Master [git repository][gh]:
+
+* `git clone https://github.com/thoughtpolice/minibsdiff.git`
+
+There's also a [BitBucket mirror][bb]:
+
+* `git clone https://bitbucket.org/thoughtpolice/minibsdiff.git`
+
+If you're going to submit a pull request or send a patch, **sign off on your
+changes** by using `git commit -s`. I manage the `Signed-off-by` field like
+git: by signing off, you acknowledge that the code you are submitting for
+inclusion abides by the license of the project. An `Acked-by` field states that
+someone has reviewed this code, and at the very least it is not completely
+insane.
+
+# Authors
+
+See [AUTHORS.txt](https://raw.github.com/thoughtpolice/minibsdiff/master/AUTHORS.txt).
+
+# License
+
+2-clause BSD. See `LICENSE.txt` for terms of copyright and redistribution.
+
+[bsdiff]: http://www.daemonology.net/bsdiff/
+[issue tracker]: http://github.com/thoughtpolice/minibsdiff/issues
+[gh]: http://github.com/thoughtpolice/minibsdiff
+[bb]: http://bitbucket.org/thoughtpolice/minibsdiff
diff -Naur -U 5 bsdiff-4.3/release.nix minibsdiff-master/release.nix
--- bsdiff-4.3/release.nix	1970-01-01 10:00:00.000000000 +1000
+++ minibsdiff-master/release.nix	2014-04-15 13:49:58.000000000 +1000
@@ -0,0 +1,90 @@
+{ minibsdiff ? { outPath = ./.; revCount = 0; shortRev = "abcdef"; rev = "HEAD"; }
+, officialRelease ? false
+}:
+
+let
+  pkgs = import <nixpkgs> { };
+
+  systems = [ "i686-linux" "x86_64-linux" ];
+
+  version = "0.0.1" + (pkgs.lib.optionalString (!officialRelease)
+    "-pre${toString minibsdiff.revCount}_${minibsdiff.shortRev}");
+
+  jobs = rec {
+    ## -- Tarballs -------------------------------------------------------------
+    tarball = pkgs.releaseTools.sourceTarball {
+      name = "minibsdiff-tarball";
+      src  = minibsdiff;
+      inherit version;
+      officialRelease = true; # hack
+      buildInputs = [ pkgs.git pkgs.xz ];
+
+      distPhase = ''
+        relname=minibsdiff-${version}
+        mkdir ../$relname
+        cp -prd . ../$relname
+        rm -rf ../$relname/.git ../$relname/svn-revision
+
+        mkdir $out/tarballs
+        tar cvfJ $out/tarballs/$relname.tar.xz -C .. $relname
+      '';
+    };
+
+    ## -- Build ----------------------------------------------------------------
+    build = pkgs.lib.genAttrs systems (system:
+      with import <nixpkgs> { inherit system; };
+
+      releaseTools.nixBuild {
+        name = "minibsdiff";
+        src  = tarball;
+        enableParallelBuilding = true;
+        doCheck = false;
+
+        installPhase = "make install PREFIX=$out";
+      }
+    );
+
+    ## -- Release build --------------------------------------------------------
+    release = pkgs.releaseTools.aggregate
+      { name = "minibsdiff-${tarball.version}";
+        constituents =
+          [ tarball
+            build.x86_64-linux
+          ];
+        meta.description = "Release-critical builds";
+      };
+  };
+
+  ## -- Utilities --------------------------------------------------------------
+  makeRPM_i686   = makeRPM "i686-linux";
+  makeRPM_x86_64 = makeRPM "x86_64-linux";
+
+  makeRPM =
+    system: diskImageFun: prio:
+
+    with import <nixpkgs> { inherit system; };
+
+    releaseTools.rpmBuild rec {
+      name = "minibsdiff-rpm";
+      src = jobs.tarball;
+      diskImage = diskImageFun vmTools.diskImages;
+      meta = { schedulingPriority = prio; };
+    };
+
+  makeDeb_i686   = makeDeb "i686-linux";
+  makeDeb_x86_64 = makeDeb "x86_64-linux";
+
+  makeDeb =
+    system: diskImageFun: prio:
+
+    with import <nixpkgs> { inherit system; };
+
+    releaseTools.debBuild {
+      name = "minibsdiff-deb";
+      src = jobs.tarball;
+      diskImage = diskImageFun vmTools.diskImages;
+      meta = { schedulingPriority = prio; };
+      debMaintainer = "Austin Seipp <aseipp@pobox.com>";
+    };
+
+in jobs
diff -Naur -U 5 bsdiff-4.3/stdbool-msvc.h minibsdiff-master/stdbool-msvc.h
--- bsdiff-4.3/stdbool-msvc.h	1970-01-01 10:00:00.000000000 +1000
+++ minibsdiff-master/stdbool-msvc.h	2014-04-15 13:49:58.000000000 +1000
@@ -0,0 +1,44 @@
+/*-
+ * stdbool-msvc.h - simple replacement for stdboo.h under Visual Studio
+ *
+ * Copyright 2012-2013 Austin Seipp
+ * All rights reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted providing that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef _MSC_VER // [
+#error "Use this header only with Microsoft Visual C++ compilers!"
+#endif // _MSC_VER ]
+
+#ifndef _MSC_STDBOOL_H_ // [
+#define _MSC_STDBOOL_H_
+
+#if _MSC_VER > 1000
+#pragma once
+#endif
+
+typedef unsigned char bool;
+
+#define true 1
+#define false 0
+
+#endif // _MSC_STDBOOL_H_ ]
diff -Naur -U 5 bsdiff-4.3/stdint-msvc.h minibsdiff-master/stdint-msvc.h
--- bsdiff-4.3/stdint-msvc.h	1970-01-01 10:00:00.000000000 +1000
+++ minibsdiff-master/stdint-msvc.h	2014-04-15 13:49:58.000000000 +1000
@@ -0,0 +1,247 @@
+// ISO C9x  compliant stdint.h for Microsoft Visual Studio
+// Based on ISO/IEC 9899:TC2 Committee draft (May 6, 2005) WG14/N1124
+//
+//  Copyright (c) 2006-2008 Alexander Chemeris
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+//   1. Redistributions of source code must retain the above copyright notice,
+//      this list of conditions and the following disclaimer.
+//
+//   2. Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//
+//   3. The name of the author may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
+// EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+// OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+// OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#ifndef _MSC_VER // [
+#error "Use this header only with Microsoft Visual C++ compilers!"
+#endif // _MSC_VER ]
+
+#ifndef _MSC_STDINT_H_ // [
+#define _MSC_STDINT_H_
+
+#if _MSC_VER > 1000
+#pragma once
+#endif
+
+#include <limits.h>
+
+// For Visual Studio 6 in C++ mode and for many Visual Studio versions when
+// compiling for ARM we should wrap <wchar.h> include with 'extern "C++" {}'
+// or compiler give many errors like this:
+//   error C2733: second C linkage of overloaded function 'wmemchr' not allowed
+#ifdef __cplusplus
+extern "C" {
+#endif
+#  include <wchar.h>
+#ifdef __cplusplus
+}
+#endif
+
+// Define _W64 macros to mark types changing their size, like intptr_t.
+#ifndef _W64
+#  if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
+#     define _W64 __w64
+#  else
+#     define _W64
+#  endif
+#endif
+
+
+// 7.18.1 Integer types
+
+// 7.18.1.1 Exact-width integer types
+
+// Visual Studio 6 and Embedded Visual C++ 4 doesn't
+// realize that, e.g. char has the same size as __int8
+// so we give up on __intX for them.
+#if (_MSC_VER < 1300)
+   typedef signed char       int8_t;
+   typedef signed short      int16_t;
+   typedef signed int        int32_t;
+   typedef unsigned char     uint8_t;
+   typedef unsigned short    uint16_t;
+   typedef unsigned int      uint32_t;
+#else
+   typedef signed __int8     int8_t;
+   typedef signed __int16    int16_t;
+   typedef signed __int32    int32_t;
+   typedef unsigned __int8   uint8_t;
+   typedef unsigned __int16  uint16_t;
+   typedef unsigned __int32  uint32_t;
+#endif
+typedef signed __int64       int64_t;
+typedef unsigned __int64     uint64_t;
+
+
+// 7.18.1.2 Minimum-width integer types
+typedef int8_t    int_least8_t;
+typedef int16_t   int_least16_t;
+typedef int32_t   int_least32_t;
+typedef int64_t   int_least64_t;
+typedef uint8_t   uint_least8_t;
+typedef uint16_t  uint_least16_t;
+typedef uint32_t  uint_least32_t;
+typedef uint64_t  uint_least64_t;
+
+// 7.18.1.3 Fastest minimum-width integer types
+typedef int8_t    int_fast8_t;
+typedef int16_t   int_fast16_t;
+typedef int32_t   int_fast32_t;
+typedef int64_t   int_fast64_t;
+typedef uint8_t   uint_fast8_t;
+typedef uint16_t  uint_fast16_t;
+typedef uint32_t  uint_fast32_t;
+typedef uint64_t  uint_fast64_t;
+
+// 7.18.1.4 Integer types capable of holding object pointers
+#ifdef _WIN64 // [
+   typedef signed __int64    intptr_t;
+   typedef unsigned __int64  uintptr_t;
+#else // _WIN64 ][
+   typedef _W64 signed int   intptr_t;
+   typedef _W64 unsigned int uintptr_t;
+#endif // _WIN64 ]
+
+// 7.18.1.5 Greatest-width integer types
+typedef int64_t   intmax_t;
+typedef uint64_t  uintmax_t;
+
+
+// 7.18.2 Limits of specified-width integer types
+
+#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS) // [   See footnote 220 at page 257 and footnote 221 at page 259
+
+// 7.18.2.1 Limits of exact-width integer types
+#define INT8_MIN     ((int8_t)_I8_MIN)
+#define INT8_MAX     _I8_MAX
+#define INT16_MIN    ((int16_t)_I16_MIN)
+#define INT16_MAX    _I16_MAX
+#define INT32_MIN    ((int32_t)_I32_MIN)
+#define INT32_MAX    _I32_MAX
+#define INT64_MIN    ((int64_t)_I64_MIN)
+#define INT64_MAX    _I64_MAX
+#define UINT8_MAX    _UI8_MAX
+#define UINT16_MAX   _UI16_MAX
+#define UINT32_MAX   _UI32_MAX
+#define UINT64_MAX   _UI64_MAX
+
+// 7.18.2.2 Limits of minimum-width integer types
+#define INT_LEAST8_MIN    INT8_MIN
+#define INT_LEAST8_MAX    INT8_MAX
+#define INT_LEAST16_MIN   INT16_MIN
+#define INT_LEAST16_MAX   INT16_MAX
+#define INT_LEAST32_MIN   INT32_MIN
+#define INT_LEAST32_MAX   INT32_MAX
+#define INT_LEAST64_MIN   INT64_MIN
+#define INT_LEAST64_MAX   INT64_MAX
+#define UINT_LEAST8_MAX   UINT8_MAX
+#define UINT_LEAST16_MAX  UINT16_MAX
+#define UINT_LEAST32_MAX  UINT32_MAX
+#define UINT_LEAST64_MAX  UINT64_MAX
+
+// 7.18.2.3 Limits of fastest minimum-width integer types
+#define INT_FAST8_MIN    INT8_MIN
+#define INT_FAST8_MAX    INT8_MAX
+#define INT_FAST16_MIN   INT16_MIN
+#define INT_FAST16_MAX   INT16_MAX
+#define INT_FAST32_MIN   INT32_MIN
+#define INT_FAST32_MAX   INT32_MAX
+#define INT_FAST64_MIN   INT64_MIN
+#define INT_FAST64_MAX   INT64_MAX
+#define UINT_FAST8_MAX   UINT8_MAX
+#define UINT_FAST16_MAX  UINT16_MAX
+#define UINT_FAST32_MAX  UINT32_MAX
+#define UINT_FAST64_MAX  UINT64_MAX
+
+// 7.18.2.4 Limits of integer types capable of holding object pointers
+#ifdef _WIN64 // [
+#  define INTPTR_MIN   INT64_MIN
+#  define INTPTR_MAX   INT64_MAX
+#  define UINTPTR_MAX  UINT64_MAX
+#else // _WIN64 ][
+#  define INTPTR_MIN   INT32_MIN
+#  define INTPTR_MAX   INT32_MAX
+#  define UINTPTR_MAX  UINT32_MAX
+#endif // _WIN64 ]
+
+// 7.18.2.5 Limits of greatest-width integer types
+#define INTMAX_MIN   INT64_MIN
+#define INTMAX_MAX   INT64_MAX
+#define UINTMAX_MAX  UINT64_MAX
+
+// 7.18.3 Limits of other integer types
+
+#ifdef _WIN64 // [
+#  define PTRDIFF_MIN  _I64_MIN
+#  define PTRDIFF_MAX  _I64_MAX
+#else  // _WIN64 ][
+#  define PTRDIFF_MIN  _I32_MIN
+#  define PTRDIFF_MAX  _I32_MAX
+#endif  // _WIN64 ]
+
+#define SIG_ATOMIC_MIN  INT_MIN
+#define SIG_ATOMIC_MAX  INT_MAX
+
+#ifndef SIZE_MAX // [
+#  ifdef _WIN64 // [
+#     define SIZE_MAX  _UI64_MAX
+#  else // _WIN64 ][
+#     define SIZE_MAX  _UI32_MAX
+#  endif // _WIN64 ]
+#endif // SIZE_MAX ]
+
+// WCHAR_MIN and WCHAR_MAX are also defined in <wchar.h>
+#ifndef WCHAR_MIN // [
+#  define WCHAR_MIN  0
+#endif  // WCHAR_MIN ]
+#ifndef WCHAR_MAX // [
+#  define WCHAR_MAX  _UI16_MAX
+#endif  // WCHAR_MAX ]
+
+#define WINT_MIN  0
+#define WINT_MAX  _UI16_MAX
+
+#endif // __STDC_LIMIT_MACROS ]
+
+
+// 7.18.4 Limits of other integer types
+
+#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS) // [   See footnote 224 at page 260
+
+// 7.18.4.1 Macros for minimum-width integer constants
+
+#define INT8_C(val)  val##i8
+#define INT16_C(val) val##i16
+#define INT32_C(val) val##i32
+#define INT64_C(val) val##i64
+
+#define UINT8_C(val)  val##ui8
+#define UINT16_C(val) val##ui16
+#define UINT32_C(val) val##ui32
+#define UINT64_C(val) val##ui64
+
+// 7.18.4.2 Macros for greatest-width integer constants
+#define INTMAX_C   INT64_C
+#define UINTMAX_C  UINT64_C
+
+#endif // __STDC_CONSTANT_MACROS ]
+
+
+#endif // _MSC_STDINT_H_ ]
diff -Naur -U 5 bsdiff-4.3/.travis.yml minibsdiff-master/.travis.yml
--- bsdiff-4.3/.travis.yml	1970-01-01 10:00:00.000000000 +1000
+++ minibsdiff-master/.travis.yml	2014-04-15 13:49:58.000000000 +1000
@@ -0,0 +1,9 @@
+language: c
+script: echo # Dummy rule
+
+matrix:
+  include:
+    - script:   make
+      compiler: clang
+    - script:   make
+      compiler: gcc
